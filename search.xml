<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java crash course 3笔记</title>
      <link href="/2025/03/09/java-crash-course-3%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/09/java-crash-course-3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or</span><br><span class="line">// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.</span><br><span class="line">public class Main &#123;</span><br><span class="line">    //可以定义全class变量</span><br><span class="line">    final static byte MONTH_IN_YEAR = 12;//静态方法只能访问静态变量</span><br><span class="line">    final static byte PERCENT = 100;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//      String message =  greetUser(&quot;rain&quot;, &quot;bow&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//int principal = (int) readNumber(&quot;principal&quot;,1000,1_000_000);//类型转换</span><br><span class="line"></span><br><span class="line">//        for (short month =1;,month &lt;=years *MONTH_IN_YEAR,month++)&#123;</span><br><span class="line">//</span><br><span class="line">//        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*  1.java的方法、method</span><br><span class="line">            a.public private都是关键字 被称为访问修饰符 ;</span><br><span class="line">            public关键字定义的method能被从class外面访问到</span><br><span class="line"></span><br><span class="line">    * */</span><br><span class="line">//void指这个函数的返回类型，什么都没有返回就是void</span><br><span class="line">//    public static void greetUser(String firstName,String lastName)//定义一个String类型的变量name,在方法中它就是局部变量了</span><br><span class="line">//    &#123;</span><br><span class="line">//        System.out.println(&quot;hello&quot; + firstName + lastName);</span><br><span class="line">//    &#125;</span><br><span class="line">//    public static String greetUser(String firstName, String lastName)//定义一个String类型的变量name,在方法中它就是局部变量了</span><br><span class="line">//    &#123;</span><br><span class="line">//        return &quot;hello&quot; + firstName + lastName;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java crash course 2.4笔记</title>
      <link href="/2025/03/09/java-crash-course-2-4%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/09/java-crash-course-2-4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>example<br>├─ CheckBox.java<br>├─ Main.java<br>├─ Point.java<br>├─ TextBox.java<br>└─ UIControl.java</p></blockquote><ol><li><p>CheckBox.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">//public abstract class CheckBox extends UIControl&#123;//因为extends了ui control 这个render方法 要不就要实现 要不就要也声明为abstract</span><br><span class="line">////    @Override</span><br><span class="line">////    public void render() &#123;//这个render方法 要不就要实现 要不就要也声明为abstract</span><br><span class="line">////        System.out.println(&quot;render checkbox&quot;);</span><br><span class="line">////    &#125;</span><br><span class="line">//&#125;</span><br><span class="line">public final class CheckBox extends UIControl&#123;//因为extends了ui control 这个render方法 要不就要实现 要不就要也声明为abstract</span><br><span class="line">    @Override</span><br><span class="line">    public void render() &#123;//这个render方法 要不就要实现 要不就要也声明为abstract</span><br><span class="line">        System.out.println(&quot;render checkbox&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//public class MyCheckBox extends CheckBox&#123;&#125;</span><br><span class="line">//public class MyCheckBox extends String&#123;&#125;//String class是不可继承的</span><br></pre></td></tr></table></figure></li><li><p>Main.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package org.example;</span><br><span class="line">//package org.codewithme;</span><br><span class="line"></span><br><span class="line">//import org.example.UIControl;</span><br><span class="line"></span><br><span class="line">//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or</span><br><span class="line">// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">// var control = new TextBox();</span><br><span class="line">// control.</span><br><span class="line">//        control.disable();</span><br><span class="line">//        System.out.println(control.isEnabled());</span><br><span class="line">//        var obj = new Object();</span><br><span class="line">//        obj.</span><br><span class="line"></span><br><span class="line">//        var box1 = new TextBox();</span><br><span class="line">//        var box2 =box1;</span><br><span class="line">//        System.out.println(box1.hashCode());</span><br><span class="line">//        System.out.println(box2.hashCode());//这个对象的地址的哈希值</span><br><span class="line">//        System.out.println(box1.equals(box2));</span><br><span class="line"></span><br><span class="line">//        var box1 = new TextBox();</span><br><span class="line">//        var box2 =new TextBox();</span><br><span class="line">//        System.out.println(box1.equals(box2));</span><br><span class="line">//        System.out.println(box1.toString());</span><br><span class="line"></span><br><span class="line">//        2.不想重复编码 使用inheritance</span><br><span class="line"></span><br><span class="line">//      3.  访问修饰符</span><br><span class="line">//        public成员可以在class外被访问 而private不能</span><br><span class="line">//</span><br><span class="line">        var textBox = new TextBox();</span><br><span class="line">//        new UIControl(true).is</span><br><span class="line">//        protected 修饰的变量在这个包里是公共的</span><br><span class="line"></span><br><span class="line">//        4.方法重写 overriding 重写继承至父类的方法</span><br><span class="line">//        方法重构 overloading ,同一个名字的方法 传参不一样</span><br><span class="line">//        var textBox = new TextBox();</span><br><span class="line">//        textBox.setText(&quot;hello world&quot;);</span><br><span class="line">//        System.out.println(textBox);//不用显示调用textBox.toString()，因为printline方法自动会调用，任何传到这个括号里的对象 的toString()方法</span><br><span class="line"></span><br><span class="line">//        System.out.println(textBox.toString());</span><br><span class="line"></span><br><span class="line">//        5.upcasting和downcasting</span><br><span class="line"></span><br><span class="line">//        var control = new UIControl(true);</span><br><span class="line">//        var textBox = new TextBox();</span><br><span class="line">//        show(textBox);//TextBox class中继承了uI ctrolclas</span><br><span class="line"></span><br><span class="line">//        6.比较两个对象</span><br><span class="line">//var point1 = new Point(1,2);</span><br><span class="line">//var point2 = new Point(1,2);</span><br><span class="line">//        System.out.println(point1==point2);//point1和point2都是引用类型，这俩东西储存的是point对象在内存中的地址，这是两个不同的对象 所以这两个变量中有不同的值</span><br><span class="line">////        System.out.println(point1.equals(point2));</span><br><span class="line">////        System.out.println(point1.equals(textBox));</span><br><span class="line">////        System.out.println(point1.equals(point1));</span><br><span class="line">//        System.out.println(point1.hashCode());</span><br><span class="line">//        System.out.println(point2.hashCode());</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//        7.面向编程的第四个特点 多态</span><br><span class="line">//UIControl[] controls = &#123;new TextBox(),new CheckBox()&#125;;</span><br><span class="line">//for (var control : controls)&#123;//for (元素类型 变量名 : 集合或数组)</span><br><span class="line">//    control.render();//多态的体现 每个类都有自己各自的render方法 而不是在主方法里写 fat if else语句</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//  8.抽象类和方法</span><br><span class="line"></span><br><span class="line">//       a.</span><br><span class="line">//        var uiControl = new UIControl();</span><br><span class="line"></span><br><span class="line">//        b.final classes 当声明一个class为此类型时 不能再extends它了</span><br><span class="line"></span><br><span class="line">//        9.多重继承 python c++类语言可以继承多个父级 但也因为带来了一些复杂性 所以java没有多重继承</span><br><span class="line">    &#125;</span><br><span class="line">//    5.upcasting和downcasting的函数</span><br><span class="line">//    public static void show(UIControl control)&#123;//调用这个方法时 TextBox被自动转换成UIControl类型，这就是upcasting</span><br><span class="line">//        if (control instanceof TextBox)&#123;//control是否是TextBox class的实列</span><br><span class="line">//            var textBox=(TextBox)control;//显示转换此对象为TextBox类型</span><br><span class="line">//            textBox.setText(&quot;ddd&quot;);//这就是downcasting,使用时要确定传到这个函数里的对象它原本就是Textbox的实列，这样就可以安全地将其转换成TextBVox了</span><br><span class="line">//        &#125;</span><br><span class="line">//        System.out.println(control);</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Point.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Point &#123;</span><br><span class="line"></span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    @Override</span><br><span class="line">//    public boolean equals(Object obj) &#123;</span><br><span class="line">//        if(this == obj)</span><br><span class="line">//            return true;</span><br><span class="line">//</span><br><span class="line">//        if (!(obj instanceof Point))</span><br><span class="line">//            return false;</span><br><span class="line">//        var other = (Point) obj;</span><br><span class="line">//            return other.x == x &amp;&amp; other.y == y;</span><br><span class="line">////        if (obj instanceof Point) &#123;</span><br><span class="line">////            var other = (Point) obj;</span><br><span class="line">////            return other.x == x &amp;&amp; other.y == y;</span><br><span class="line">////        &#125;</span><br><span class="line">////        return false;</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Point point = (Point) o;</span><br><span class="line">        return x == point.x &amp;&amp; y == point.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">//    @Override</span><br><span class="line">//    public int hashCode() &#123;</span><br><span class="line">//       return Objects.hash(x,y);//哈希值理论上是 标志对象的唯一值</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TextBox.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">public class TextBox extends UIControl &#123;</span><br><span class="line">//    textBox继承了uiconrol class中所有的特性</span><br><span class="line">//</span><br><span class="line">    private String text = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">//    public TextBox() &#123;</span><br><span class="line">//        super(true);//显示调用父级 extends对象的构造函数</span><br><span class="line">////        this.is//subclass不能访问 baseClass的private field methods</span><br><span class="line">////        System.out.println(&quot;text box&quot;);</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public void setText(String text) &#123;</span><br><span class="line">        this.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        text = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override//这种叫注释,这一句的目的是告诉java我们重写了toString这个方法</span><br><span class="line">    public String  toString()&#123;</span><br><span class="line">        return text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void render() &#123;</span><br><span class="line">        System.out.println(&quot;render textbox&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UIControl.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">public abstract class UIControl &#123;//声明这一类为abstract后 此class不能再被实列化了 ，只能继承extends 它</span><br><span class="line">//    private boolean isEnabled = true;</span><br><span class="line">protected boolean isEnabled = true;//protected is public in pacakage,即只要在package org.example;中isEnabled就是公共字段</span><br><span class="line"></span><br><span class="line">//    public UIControl(boolean isEnabled) &#123;</span><br><span class="line">//        this.isEnabled =isEnabled;</span><br><span class="line">//        System.out.println(&quot;ui conrol&quot;);</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">//    public void enable()&#123;</span><br><span class="line">//        isEnabled = true;</span><br><span class="line">//    &#125;</span><br><span class="line">public final void enable()&#123;//final 方法是不能override的</span><br><span class="line">    isEnabled = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public void disable()&#123;</span><br><span class="line">        isEnabled = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEnabled()&#123;</span><br><span class="line">        return isEnabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    定义一个泛型方法</span><br><span class="line">//    public void render()&#123;</span><br><span class="line">//</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void render();//声明此方法为abstract 删除&#123;&#125;编成方法的声明而不是实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java crash course 2.2笔记</title>
      <link href="/2025/03/09/java-crash-course-2-2%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/09/java-crash-course-2-2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line"></span><br><span class="line">//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or</span><br><span class="line">// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123; //main方法是静态的是 因为直接使用此方法 而不用再去创建新对象见最后一点</span><br><span class="line">//            TextBox textBox1 = new TextBox();</span><br><span class="line">//        var textBox1 = new TextBox(); //var关键字 java编译器会根据等号右边的类型自动给变量赋上适合的类型，这种变量是静态的，一旦赋值不可修改，和js中的var是两个不同的东西</span><br><span class="line">//        textBox1.setText(&quot;Box 1&quot;);</span><br><span class="line">//        System.out.println(textBox1.text.toUpperCase());</span><br><span class="line">//</span><br><span class="line">//        var textBox2= new TextBox(); //var关键字 java编译器会根据等号右边的类型自动给变量赋上适合的类型，这种变量是静态的，一旦赋值不可修改，和js中的var是两个不同的东西</span><br><span class="line">//        textBox2.setText(&quot;Box 2&quot;);</span><br><span class="line">//        System.out.println(textBox2.text);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /*2.内存分配</span><br><span class="line"></span><br><span class="line">heap</span><br><span class="line">stack</span><br><span class="line">当运行完一个method java会自动删除储存在stack上的变量</span><br><span class="line">同时java也会自己看 在heap上没有用的对象 没用就删除 这叫做gabage collection</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">//        var textBox1 = new TextBox();//变量textBox1 正在引用在heap上的值，所以这些变量被称为引用类型，因为这些变量并不存储实际的值；而如果申明一个原始 类型int的变量，这个int是储存在stack中的，而此变量的值将会被储存在那个储存地址</span><br><span class="line">//        var textBox2 = textBox1;//textBox2\textBox1都在引用同一个在heap上的对象，所以没有两个不同的对象，在heap上只有一个对象；而在stack上有两个对象是引用这个对象，正如式子所见，赋值只是把值给赋值到了textBox2；实际我们得到的是对象在heap上的地址</span><br><span class="line">//        textBox2.setText(&quot;Hello world&quot;);//所以改变其中一个变量另外的变量也能看到这个改变</span><br><span class="line">//        System.out.println(textBox1.text);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         *3.</span><br><span class="line">         * */</span><br><span class="line">//        如果功能变多 main method会变得很臃肿,这叫做程序性编程 -mosh</span><br><span class="line">//        int baseSalary = 50_000;</span><br><span class="line">//        int extraHours = 10;</span><br><span class="line">//        int hourlyRate = 20;</span><br><span class="line">//</span><br><span class="line">//        int wage = calculateWage(baseSalary, extraHours, hourlyRate);</span><br><span class="line">//        System.out.println(wage);</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    public static int calculateWage(int baseSalary, int extraHours, int hourlyRate) &#123;</span><br><span class="line">//        return baseSalary + (extraHours * hourlyRate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         *  4.面向对象编程的规则</span><br><span class="line">         *   (1).封装 encapsulation</span><br><span class="line">         *</span><br><span class="line">         * */</span><br><span class="line">//        var employee =new Employee();</span><br><span class="line">//        employee.baseSalary = 50_000;</span><br><span class="line">//        employee.hourlyRate = 20;</span><br><span class="line">//        int wage =employee.calculateWage(10);</span><br><span class="line"></span><br><span class="line">//        var employee = new Employee();</span><br><span class="line">//        employee.setBaseSalary(-1);</span><br><span class="line">//        employee.setHourlyRate(20);</span><br><span class="line">//        int wage = employee.calculateWage(10);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //    使用intellij快速创建getter和setter</span><br><span class="line">//    (2).抽象</span><br><span class="line">//    a.coupling耦合</span><br><span class="line">//        ex.1</span><br><span class="line">//    var employee = new Employee();</span><br><span class="line">//        employee.setBaseSalary(-1);</span><br><span class="line">//        employee.setHourlyRate(20);</span><br><span class="line">//    int wage = employee.calculateWage(10);// 以上四句话都和ｅｍｐｌｏｙｅｅ　ｃｌａｓｓ耦合了,一个class提供的方法越多，越有可能被其他类耦合</span><br><span class="line">//employee.尽量减少暴露在class外的东西</span><br><span class="line"></span><br><span class="line">//        ex.2</span><br><span class="line">//        var browser = new Browser();</span><br><span class="line">//        browser.navigate();</span><br><span class="line"></span><br><span class="line">//        ex.3</span><br><span class="line">//        var employee = new Employee(50_000);//构造函数用于构造或创建一个新的对象</span><br><span class="line">//        employee.calculateWage(10);</span><br><span class="line">//        int wage = employee.calculateWage();</span><br><span class="line"></span><br><span class="line">//        b.重载构造函数</span><br><span class="line">//        ctrl b 快速跳到函数</span><br><span class="line">//        ctrl p 查看这个函数有哪些传参</span><br><span class="line"></span><br><span class="line">//        c.静态字段和方法 static</span><br><span class="line">//</span><br><span class="line">//        Employee.</span><br><span class="line">        var employee = new Employee(50_000);</span><br><span class="line">            Employee.printNumberOfEmployees();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/09/js%E7%AC%AC8%E7%AB%A0/"/>
      <url>/2025/03/09/js%E7%AC%AC8%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>第 8 章对象、类与面向对象编程</p><h3 id="属性分两种：数据属性和访问器属性"><a href="#属性分两种：数据属性和访问器属性" class="headerlink" title="属性分两种：数据属性和访问器属性"></a>属性分两种：数据属性和访问器属性</h3><ol><li>数据属性<br>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。<br>有 4 个特性描述它们的行为<ul><li> [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，</li><li>[[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值 undefined。</li></ul></li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个构造函数都有一个原型对象，原型有<br>一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味<br>着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函<br>数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 类声明</span><br><span class="line">class Person &#123;&#125;</span><br></pre></td></tr></table></figure><p>类构造函数<br>constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line"> constructor() &#123;</span><br><span class="line"> console.log(&#x27;person ctor&#x27;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Vegetable &#123;</span><br><span class="line"> constructor() &#123;</span><br><span class="line"> this.color = &#x27;orange&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal();</span><br><span class="line">let p = new Person(); // person ctor</span><br><span class="line">let v = new Vegetable();</span><br><span class="line">console.log(v.color); // orange</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>ES6 类支持单继承。使用 extends 关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Vehicle &#123;&#125;</span><br><span class="line">// 继承类</span><br><span class="line">class Bus extends Vehicle &#123;&#125;</span><br><span class="line">let b = new Bus();</span><br><span class="line">console.log(b instanceof Bus); // true</span><br><span class="line">console.log(b instanceof Vehicle); // true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/09/js%E7%AC%AC7%E7%AB%A0/"/>
      <url>/2025/03/09/js%E7%AC%AC7%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="第-7-章"><a href="#第-7-章" class="headerlink" title="第 7 章"></a>第 7 章</h3><p>迭代的英文“iteration”源自拉丁文 itero，意思是“重复”或“再来”。一遍又一遍来</p><p>最简单的迭代</p><figure class="highlight plaintext"><figcaption><span>(let i </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set<br>设置, 集, 组, 设定, 集合, 一套<br>检查是否存在默认迭代器属性</p><figure class="highlight plaintext"><figcaption><span>str </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(str[Symbol.iterator]); // f values() &#123; [native code] &#125; ```</span><br><span class="line">任何实现 Iterable接口的对象都有一个 Symbol.iterator 属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数组解构</span><br><span class="line">// 扩展操作符</span><br><span class="line">let arr2 = [...arr];</span><br><span class="line">console.log(arr2); // [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span><br><span class="line"></span><br><span class="line">#### 生成器</span><br><span class="line">生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义</span><br><span class="line">函数的地方，就可以定义生成器。</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 生成器函数声明<br>function* generatorFn() {}<br>&#x2F;&#x2F; 生成器函数表达式<br>let generatorFn &#x3D; function* () {}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与</span><br><span class="line">迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器</span><br><span class="line">开始或恢复执行</span><br></pre></td></tr></table></figure><p>function* generatorFn() {}<br>const g &#x3D; generatorFn();<br>console.log(g); &#x2F;&#x2F; generatorFn {<suspended>}<br>console.log(g.next); &#x2F;&#x2F; f next() { [native code] }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#### 通过 yield 中断执行</span><br><span class="line">yield 关键字可以让生成器停止和开始执行，生成器函数在遇到 yield</span><br><span class="line">关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生</span><br><span class="line">成器函数只能通过在生成器对象上调用 next()方法来恢复执行：</span><br></pre></td></tr></table></figure><p>function* generatorFn() {<br>yield;<br>}<br>let generatorObject &#x3D; generatorFn();<br>console.log(generatorObject.next()); &#x2F;&#x2F; { done: false, value: undefined }<br>console.log(generatorObject.next()); &#x2F;&#x2F; { done: true, value: undefined }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/09/js%E7%AC%AC6%E7%AB%A0/"/>
      <url>/2025/03/09/js%E7%AC%AC6%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="第-6-章"><a href="#第-6-章" class="headerlink" title="第 6 章"></a>第 6 章</h3><h4 id="创建-Object"><a href="#创建-Object" class="headerlink" title="创建 Object"></a>创建 Object</h4><p>显式地创建 Object 的实例有两种方式。</p><ol><li>使用 new 操作符， Object 构造函数</li></ol><figure class="highlight plaintext"><figcaption><span>person </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">person.name = &quot;Nicholas&quot;;```</span><br><span class="line">2. 对象字面量（object literal）[字面意思]</span><br><span class="line">```let person = &#123;</span><br><span class="line">&quot;name&quot;: &quot;Nicholas&quot;,</span><br><span class="line">&quot;age&quot;: 29</span><br><span class="line">&#125;;```</span><br><span class="line"></span><br><span class="line">#### 创建数组</span><br><span class="line">1. 使用 Array 构造函数，比如：let colors = new Array();</span><br><span class="line">2. 数组字面量（array literal）表示法</span><br><span class="line">let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个元素的数组</span><br><span class="line">Array.from() 的第一个参数是一个类数组对象</span><br><span class="line">```// 字符串会被拆分为单字符数组</span><br><span class="line">console.log(Array.from(&quot;Matt&quot;)); // [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]```</span><br><span class="line">判断一个对象是不是数组。:</span><br><span class="line">```if (value instanceof Array)&#123;</span><br><span class="line">// 操作数组</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line"> Array.isArray() 方法</span><br><span class="line">```if (Array.isArray(value))&#123;</span><br><span class="line">// 操作数组</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line"> fill() 方法可以向数组填充指定的值</span><br><span class="line"> ```const zeroes = [0, 0, 0, 0, 0];</span><br><span class="line">// 用 5 填充整个数组</span><br><span class="line">zeroes.fill(5);</span><br><span class="line">console.log(zeroes); // [5, 5, 5, 5, 5]</span><br><span class="line">zeroes.fill(0); // 重置```</span><br><span class="line"></span><br><span class="line"> toString() 方法，以得到最终的字符串</span><br><span class="line">```let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组</span><br><span class="line">alert(colors.toString()); // red,blue,green```</span><br><span class="line"></span><br><span class="line">- ECMAScript 数组提供了 push() 和 pop() 方法，以实现类似栈的行为。</span><br><span class="line">push() 方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。</span><br><span class="line"> pop() 方法则</span><br><span class="line">用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。来看下面的例子：</span><br><span class="line">```let colors = new Array(); // 创建一个数组</span><br><span class="line">let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项</span><br><span class="line">alert(count); // 2</span><br><span class="line">count = colors.push(&quot;black&quot;); // 再推入一项</span><br><span class="line">alert(count); // 3</span><br><span class="line">let item = colors.pop(); // 取得最后一项</span><br><span class="line">alert(item); // black```</span><br><span class="line">- 队列方法</span><br><span class="line">就像栈是以 LIFO 形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式</span><br><span class="line">限制访问。</span><br><span class="line">shift() ，它会删除数</span><br><span class="line">组的第一项并返回它，然后数组长度减 1。</span><br></pre></td></tr></table></figure><p>let count &#x3D; colors.push(“red”, “green”); &#x2F;&#x2F; 推入两项<br>alert(count); &#x2F;&#x2F; 2<br>count &#x3D; colors.push(“black”); &#x2F;&#x2F; 再推入一项<br>alert(count); &#x2F;&#x2F; 3<br>let item &#x3D; colors.shift(); &#x2F;&#x2F; 取得第一项<br>alert(item); &#x2F;&#x2F; red</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">indexOf() 和 lastIndexOf() 都返回要查找的元素在数组中的位置，如果没找到则返回1。</span><br><span class="line">```let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">alert(numbers.indexOf(4)); // 3</span><br><span class="line">alert(numbers.lastIndexOf(4)); // 5</span><br></pre></td></tr></table></figure><ul><li>迭代方法</li></ul><figure class="highlight plaintext"><figcaption><span>numbers </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);</span><br><span class="line">alert(filterResult); // 3,4,5,4,3```</span><br><span class="line"> map方法非常适合创建一个与原</span><br><span class="line">始数组元素一一对应的新数组。</span><br><span class="line">```let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">let mapResult = numbers.map((item, index, array) =&gt; item * 2);</span><br><span class="line">alert(mapResult); // 2,4,6,8,10,8,6,4,2</span><br></pre></td></tr></table></figure><ul><li>归并方法<br>这两个方法都会迭代数<br>组的所有项，并在此基础上构建一个最终返回值。</li></ul><p>可以使用 reduce() 函数执行累加数组中所有数值的操作，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let values = [1, 2, 3, 4, 5];</span><br><span class="line">let sum = values.reduce((prev, cur, index, array) =&gt; prev + cur);</span><br><span class="line">alert(sum); // 15</span><br></pre></td></tr></table></figure><ul><li>webGl<br>有了它，开发者就能够编写涉及复杂图形的应用程序</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>与 Object 只能使用数值、字符串或符号作为键不同， Map 可以使用任何 JavaScript 数据类型作为<br>键。<br>使用 new 关键字和 Map 构造函数可以创建一个空映射：<br>const m &#x3D; new Map();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ 使用嵌套数组初始化映射</span><br><span class="line">const m1 = new Map([</span><br><span class="line">[&quot;key1&quot;, &quot;val1&quot;],</span><br><span class="line">[&quot;key2&quot;, &quot;val2&quot;],</span><br><span class="line">[&quot;key3&quot;, &quot;val3&quot;]</span><br><span class="line">]);</span><br><span class="line">alert(m1.size); // 3</span><br></pre></td></tr></table></figure><p>初始化之后，可以使用 set() 方法再添加键&#x2F;值对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map().set(&quot;key1&quot;, &quot;val1&quot;);</span><br><span class="line">m.set(&quot;key2&quot;, &quot;val2&quot;)</span><br><span class="line">.set(&quot;key3&quot;, &quot;val3&quot;);</span><br><span class="line">alert(m.size); // 3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const symbolKey = Symbol();</span><br><span class="line"></span><br><span class="line">m.set(symbolKey, &quot;symbolValue&quot;);</span><br><span class="line">alert(m.get(symbolKey)); // symbolValue</span><br></pre></td></tr></table></figure><p>从大型 Object 和 Map 中查找键&#x2F;值对的性能差异极小，但如果只包含少量键&#x2F;值对，<br>则 Object 有时候速度更快。</p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>ECMAScript 6 新增的 Set 是一种新集合类型，为这门语言带来集合数据结构<br>使用 new 关键字和 Set 构造函数可以创建一个空集合：<br>const m &#x3D; new Set();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用数组初始化集合</span><br><span class="line">const s1 = new Set([&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]);</span><br><span class="line">alert(s1.size); // 3</span><br></pre></td></tr></table></figure><p>初始化之后，可以使用 add() 增加值，使用 has() 查询，通过 size 取得元素数量，以及使用 delete()<br>和 clear() 删除元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line">alert(s.has(&quot;Matt&quot;)); // false</span><br><span class="line">alert(s.size); // 0</span><br><span class="line">s.add(&quot;Matt&quot;)</span><br><span class="line">.add(&quot;Frisbie&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/09/js%E7%AC%AC5%E7%AB%A0/"/>
      <url>/2025/03/09/js%E7%AC%AC5%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="要创建一个表示“2019-年-5-月-23-日”的日期对象，可以使用以下代码："><a href="#要创建一个表示“2019-年-5-月-23-日”的日期对象，可以使用以下代码：" class="headerlink" title="要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码："></a>要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：</h4><p><code>let someDate = new Date(Date.parse(&quot;May 23, 2019&quot;))</code></p><h4 id="正则表达式-RegExp"><a href="#正则表达式-RegExp" class="headerlink" title="正则表达式 RegExp"></a>正则表达式 RegExp</h4><p><code>var patt = /runoob/i</code><br>&#x2F;runoob&#x2F;i 是一个正则表达式。</p><p>runoob 是一个正则表达式主体 (用于检索)。</p><p>i ：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</p><p>正则表达式参数可用在以上方法中 (替代字符串参数)。<br>正则表达式使得搜索功能更加强大(如实例中不区分大小写)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = document.getElementById(&quot;demo&quot;).innerHTML;</span><br><span class="line">var txt = str.replace(/microsoft/i,&quot;Runoob&quot;);</span><br></pre></td></tr></table></figure><h4 id="URL-编码方法"><a href="#URL-编码方法" class="headerlink" title="URL 编码方法"></a>URL 编码方法</h4><p>有效的 URI 不能包含某些字符，比如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解它们</p><figure class="highlight plaintext"><figcaption><span>uri </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">console.log(encodeURI(uri));</span><br><span class="line">// &quot;http://www.wrox.com/illegal%20value.js#start&quot;```</span><br><span class="line">使用 encodeURI() 编码后，空格被替换为 %20</span><br><span class="line"></span><br><span class="line">#### eval() 方法</span><br><span class="line">它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串,会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置。</span><br><span class="line">通过 eval() 执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eval(&quot;console.log(&#x27;hi&#x27;)&quot;);</span><br><span class="line">等价：</span><br><span class="line">console.log(&quot;hi&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Math</span><br><span class="line"> Math 对象提供了一些辅助计算的属性和方法。</span><br><span class="line">Math.SQRT1_2 //1/2的平方根</span><br><span class="line">- min() 和 max() 方法</span><br><span class="line">  用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如</span><br><span class="line">下面的例子所示：</span><br><span class="line">```let max = Math.max(3, 54, 32, 16);</span><br><span class="line">console.log(max); // 54```</span><br><span class="line"></span><br><span class="line">- 舍入方法</span><br><span class="line">  Math.ceil() 方法始终向上舍入为最接近的整数</span><br><span class="line">  Math.round() 方法执行四舍五入</span><br><span class="line">   ```console.log(Math.ceil(25.1)); // 26</span><br><span class="line">      console.log(Math.round(25.5)); // 26</span><br><span class="line">      console.log(Math.round(25.1)); // 25</span><br></pre></td></tr></table></figure><p>random() 方法<br>let num &#x3D; Math.floor(Math.random() * 10 + 1);<br>方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/09/js%E7%AC%AC10%E7%AB%A0/"/>
      <url>/2025/03/09/js%E7%AC%AC10%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>第 10 章函数</strong></p><h3 id="属性分两种：数据属性和访问器属性"><a href="#属性分两种：数据属性和访问器属性" class="headerlink" title="属性分两种：数据属性和访问器属性"></a>属性分两种：数据属性和访问器属性</h3><ol><li>数据属性<br>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。<br>有 4 个特性描述它们的行为<ul><li> [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，</li><li>[[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值 undefined。</li></ul></li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个构造函数都有一个原型对象，原型有<br>一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味<br>着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函<br>数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 类声明</span><br><span class="line">class Person &#123;&#125;</span><br></pre></td></tr></table></figure><p>类构造函数<br>constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line"> constructor() &#123;</span><br><span class="line"> console.log(&#x27;person ctor&#x27;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Vegetable &#123;</span><br><span class="line"> constructor() &#123;</span><br><span class="line"> this.color = &#x27;orange&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = new Animal();</span><br><span class="line">let p = new Person(); // person ctor</span><br><span class="line">let v = new Vegetable();</span><br><span class="line">console.log(v.color); // orange</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>ES6 类支持单继承。使用 extends 关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Vehicle &#123;&#125;</span><br><span class="line">// 继承类</span><br><span class="line">class Bus extends Vehicle &#123;&#125;</span><br><span class="line">let b = new Bus();</span><br><span class="line">console.log(b instanceof Bus); // true</span><br><span class="line">console.log(b instanceof Vehicle); // true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java crash course-1语法笔记</title>
      <link href="/2025/03/09/java-crash-course-1%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/09/java-crash-course-1%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.text.NumberFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Locale;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello world&quot;);// system代表java中的system类;println ln是line的缩写,java中的string是用双引号的</span><br><span class="line"></span><br><span class="line">//1.void 是java的保留关键字</span><br><span class="line"></span><br><span class="line">//2.函数 function</span><br><span class="line">/*</span><br><span class="line">    函数是java中的最小块</span><br><span class="line"></span><br><span class="line">    java函数的大括号和中括号在同一行</span><br><span class="line"></span><br><span class="line">    函数始终属于一个类</span><br><span class="line"></span><br><span class="line">    method的命名方式是camel 小驼峰 第一个开头字母小写</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//3.class</span><br><span class="line">/*</span><br><span class="line">    class就像一个超市，是相关功能的容器</span><br><span class="line"></span><br><span class="line">    每一个java程序至少应该包含一个main()函数的类，这个类的名称叫做Main</span><br><span class="line"></span><br><span class="line">    class Main &#123;</span><br><span class="line">    void main()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class的命名方式是Pascal 第一个字母大写</span><br><span class="line"></span><br><span class="line">    在某些语言中，如果一个函数function被包含在了一个class里，那么这个函数被称作方法method</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">//4.访问修饰符</span><br><span class="line">/*</span><br><span class="line">    类和方法都应该有一个访问修饰符</span><br><span class="line"></span><br><span class="line">    访问修饰符是一个特殊关键字，它确定该程序的其他类和方法是否可以访问被标记的类和方法</span><br><span class="line"></span><br><span class="line">    例如public、private,放在类和方法申明的前面</span><br><span class="line"></span><br><span class="line">    public class Main &#123;</span><br><span class="line">        public void main()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    这也是java程序的基本结构 有一个Main class 一个main()函数</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">//5.$代表命令提示符</span><br><span class="line"></span><br><span class="line">//6.变量</span><br><span class="line">/*</span><br><span class="line">int age = 30;</span><br><span class="line">age=35;</span><br><span class="line">System.out.println(age);</span><br><span class="line">int myAge =30;</span><br><span class="line">int herAge=myAge;</span><br><span class="line">System.out.println(herAge);</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">//7.java中的type</span><br><span class="line">//    a.原始类型primitive 用于储存简单值</span><br><span class="line">//    b.引用类型reference 用于储存复杂的对象</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">原始类型(用来储存简单数据)</span><br><span class="line"></span><br><span class="line">只能储存整数的：</span><br><span class="line"></span><br><span class="line">byte    占用一个字节Byte     能储存[-128,127]的值</span><br><span class="line">short   占用2个字节          能储存[-32k,32k]的值 k即千</span><br><span class="line">int     占用4个字节          能储存[-2B,2B]的值 B即BILLION 十个亿</span><br><span class="line">long    占用8个字节</span><br><span class="line"></span><br><span class="line">用来储存小数的：</span><br><span class="line"></span><br><span class="line">float    占用4个字节</span><br><span class="line">double    占用8个字节</span><br><span class="line"></span><br><span class="line">用来储存字符的</span><br><span class="line">char     占用2个字节     比如说A,B,C</span><br><span class="line"></span><br><span class="line">用来储存布尔值的：</span><br><span class="line">boolean   占用1个字节    true/false</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">//byte age =24</span><br><span class="line"></span><br><span class="line">//int viewsCount =3_123_456_789</span><br><span class="line">//long viewsCount =3_123_456_789L;//加上L作为后缀 报错，让编译器以为这个数字就是long类型、每三位数字=可以用一个下划线</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//float price=10.99F;</span><br><span class="line">//char letter =&#x27;A&#x27;//单引号 引用单个字符、双引号引用多个字符</span><br><span class="line">//boolean isFilm = false;//橙色的就是 保留关键字，命名变量时不能用保留关键字</span><br><span class="line"></span><br><span class="line">        /*8.引用类型</span><br><span class="line">         * 用来储存 复杂的对象 如日期对象</span><br><span class="line">         * java的引用类型 需要使用new运算符实例化得到变量</span><br><span class="line">         * */</span><br><span class="line">//</span><br><span class="line">//Date now = new Date(); //一个对象 即是一个类的实例</span><br><span class="line">////now.getTime(); //可以使用点方位对象里的方法</span><br><span class="line">//System.out.println(now);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//byte x =1;</span><br><span class="line">//byte y =1;</span><br><span class="line">//x=2;</span><br><span class="line">//System.out.println(y);</span><br><span class="line"></span><br><span class="line">//引用类型是指命名变量时 即以为是 不同的两个变量A，b 其实是引用了同一个对象 同一个地址，即同一个对象</span><br><span class="line">//引用类型的复制是 复制的引用值</span><br><span class="line">//原始类型的复制是 复制的值 这两个值复制出来完全不一样</span><br><span class="line">//        Point point1 = new Point(1,2)</span><br><span class="line">//        Point point2 = point1;</span><br><span class="line">//        point1.x=2;</span><br><span class="line">//        System.out.println(point2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  初始化一个字符串变量的方式</span><br><span class="line">//        a.使用new</span><br><span class="line">//String message = new String(&#x27;hey String&#x27;)</span><br><span class="line">//         b.直接字面意思赋值</span><br><span class="line">//        String message = &quot;hi String&quot;;</span><br><span class="line">//        System.out.println(message);</span><br><span class="line"></span><br><span class="line">//        c.对字符串的操作</span><br><span class="line">//                1.用＋号拼接字符串</span><br><span class="line">//        String message = &quot;hi String&quot; + &quot;keys&quot; + &quot;!!&quot;;</span><br><span class="line">//        System.out.println(message);</span><br><span class="line">//                 2.使用点 可以看到 字符串类的所有方法和函数</span><br><span class="line">//        System.out.println(message.startsWith(&quot;!!&quot;)); //endwidth length indexOf[某字符第一次出现的下标]</span><br><span class="line">//        System.out.println(message.replace(&quot;!!&quot;,&quot;;;;&quot;)); //endwidth length indexOf[某字符第一次出现的下标]</span><br><span class="line">//         trim ()去掉开头结尾多余的空格</span><br><span class="line">//        3.如何在字符串中 写特殊字符 使用返斜杠\</span><br><span class="line">//        String message = &quot;hey \&quot;rain\&quot;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//   反斜杠 像windows c \</span><br><span class="line">//        String message = &quot;c \\file\n sec&quot;;</span><br><span class="line">//</span><br><span class="line">//        System.out.println(message);</span><br><span class="line"></span><br><span class="line">        /*9.jsva的数组的*/</span><br><span class="line"></span><br><span class="line">//        int number =1;</span><br><span class="line">//        int[] numbers = new int[5]; //数组数组int[] ；数组名numbers；数组是引用类型所以需要呢哇 new int[5]</span><br><span class="line">//        numbers[0] =1;</span><br><span class="line">////        System.out.println(numbers); //打印出内存地址</span><br><span class="line">//</span><br><span class="line">////                转换成字符串</span><br><span class="line">//        System.out.println(Arrays.toString(numbers)); //打印出内存地址</span><br><span class="line"></span><br><span class="line">//        a.另一种命名的方式</span><br><span class="line">//        int [] numbers = &#123;2,3,4,5,6&#125;; //java中一旦创建了数组就不能删除 或者添加</span><br><span class="line"></span><br><span class="line">//        b.创建多维数组</span><br><span class="line">//        int [][] numbers = new int[2][3]; //代表2行3列</span><br><span class="line">//        numbers[0][0] =1; //将第一行 第一列初始化为1</span><br><span class="line">////        System.out.println(Arrays.toString(numbers));</span><br><span class="line">////       //处理多重数组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//        c.用花括号赋值 多维数组 （字面量？</span><br><span class="line">//        int [][] numbers = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;</span><br><span class="line">//        System.out.println(Arrays.deepToString(numbers));</span><br><span class="line"></span><br><span class="line">        /*10.java里的常变量 用全大写命名常常*/</span><br><span class="line">//        float pi =3.14F;</span><br><span class="line">//     final float PI =3.14F;</span><br><span class="line">//        PI =1;</span><br><span class="line"></span><br><span class="line">        /*11.算术表达式(加减乘除)*/</span><br><span class="line">//        a.除法;</span><br><span class="line"></span><br><span class="line">//        int result =10/3;</span><br><span class="line">//        double result =(double) 10/(double) 3;</span><br><span class="line">//        System.out.println(result); //java中 除法得到的是整数</span><br><span class="line"></span><br><span class="line">//        b.增量运算 ++</span><br><span class="line">//        int x=1;</span><br><span class="line">//</span><br><span class="line">////        int y = x++; //增量运算号放在后缀时，x会先赋值给y,再去加自加1</span><br><span class="line">//        int y = ++x; //增量运算号放在前缀时，x会先增加1,再去赋值给y</span><br><span class="line">//</span><br><span class="line">//        System.out.println(x);</span><br><span class="line">//        System.out.println(y);</span><br><span class="line"></span><br><span class="line">//        c.增强复合运算符，如果想让自增的不是1而是2</span><br><span class="line">//        int x=1;</span><br><span class="line">////        x = x+2;</span><br><span class="line">////        x += 2 ;//更简短了</span><br><span class="line">////        x-=2;</span><br><span class="line">//        x/=2;</span><br><span class="line">//</span><br><span class="line">//        System.out.println(x);</span><br><span class="line"></span><br><span class="line">//        d.()总是优先级</span><br><span class="line">//        int x = (10+3) *2;</span><br><span class="line"></span><br><span class="line">        /*12.强制类型转换*/</span><br><span class="line">//        a.隐式转换</span><br><span class="line">//        short x =1;</span><br><span class="line">//        int y = x+2; //两种类型的值 被转换成了同一种类型;  shiort类型的值被复制到了Integer的内存做加法，//隐式转换</span><br><span class="line">//        byte &gt; short &gt; int &gt; long byte可以被这样转化</span><br><span class="line"></span><br><span class="line">//        double x =1.1;</span><br><span class="line">//        double y = x+2;//小数有更精确的描述可以包括2，int 2会被转换成 double</span><br><span class="line">//        byte &gt; short &gt; int &gt; long &gt;float &gt;double</span><br><span class="line"></span><br><span class="line">//        如果想要加的结果是int的</span><br><span class="line">//        int y = (int)x+2;//显式转换 只能发生在能兼容的数据类型中数字类型</span><br><span class="line">//        System.out.println(y);</span><br><span class="line"></span><br><span class="line">//        b.把字符串类型转换成数字</span><br><span class="line">//        String x =&quot;1&quot;;</span><br><span class="line">//        Integer.parseInt(x);//转换成数字</span><br><span class="line">//        int y = Integer.parseInt(x) + 2;</span><br><span class="line">//        System.out.println(y);</span><br><span class="line"></span><br><span class="line">//        String x =&quot;1.1&quot;;</span><br><span class="line">//        double y = Double.parseDouble(x) + 2;</span><br><span class="line">//        System.out.println(y);</span><br><span class="line"></span><br><span class="line">//        13.数学类</span><br><span class="line">//       int result = (int)Math.floor(1.1);</span><br><span class="line">//        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        /*14.格式化数字*/</span><br><span class="line">//        NumberFormat currency = new NumberFormat()//看报错，这个class是absracted 抽象的类不能使用new运算符</span><br><span class="line">//        NumberFormat currency =  NumberFormat.getCurrencyInstance();//转换成钱的字符串</span><br><span class="line">//       String result=  currency.format(123456.932);</span><br><span class="line"></span><br><span class="line">//       a.链式方法</span><br><span class="line">//      String result=  NumberFormat.getPercentInstance().format(0.1);//NumberFormat.getPercentInstance()返回了一个对象，直接点出来</span><br><span class="line">//        System.out.println(result); //shift f6选择变量名快速改名</span><br><span class="line"></span><br><span class="line">        /*15.读取java的输入*/</span><br><span class="line">//        从终端窗口键入还是</span><br><span class="line">//       Scanner scanner = new Scanner(System.in);//通过new获得一个scanner对象 终端窗口输入</span><br><span class="line">////byte age = scanner.nextByte();//返回一个byte类型的值 读取</span><br><span class="line">//        System.out.print(&quot;Name:&quot;);</span><br><span class="line">////        String age = scanner.next();//如果输入空格的话 只能读取到空格前的</span><br><span class="line">//        String age = scanner.nextLine().trim();//解决使用nextLine</span><br><span class="line">////        读取一个String的值</span><br><span class="line">//        System.out.println(&quot;you are&quot;+ age);</span><br><span class="line"></span><br><span class="line">        /*16.控制执行流程 control flow*/</span><br><span class="line">//        a.比较运算符</span><br><span class="line">//int x=1;</span><br><span class="line">//int y=1;</span><br><span class="line">//        System.out.println(x==y);//比较等于运算符== ,&lt;=</span><br><span class="line"></span><br><span class="line">//b.逻辑运算符</span><br><span class="line">//        int temperature =22;</span><br><span class="line">//        boolean isWarm = temperature &gt;20&amp;&amp; temperature&lt;30; //从左到有执行，只要第一个返回false就不会再去看第二个表达式</span><br><span class="line">//        System.out.println(isWarm);</span><br><span class="line"></span><br><span class="line">//        boolean hasHighIncome =true;</span><br><span class="line">//        boolean hasG =true;</span><br><span class="line">//        boolean isE = hasHighIncome ||  hasG; //从左到有执行，只要第一个返回TRUE就不会再去看第二个表达式,如果第一个是false，是会去看第二个式子的</span><br><span class="line">//        System.out.println(isE);</span><br><span class="line"></span><br><span class="line">//                boolean hasHighIncome =true;</span><br><span class="line">//        boolean hasG =true;</span><br><span class="line">//        boolean hasCrime = false;</span><br><span class="line">//        boolean isE = (hasHighIncome ||  hasG)&amp;&amp; !hasCrime; //!取反</span><br><span class="line">//        System.out.println(isE);</span><br><span class="line"></span><br><span class="line">//c.if语句</span><br><span class="line">//        int temp =32;</span><br><span class="line">//        if (temp&gt;30)&#123;</span><br><span class="line">//            System.out.println(&quot;hott day&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line">//        else if (temp &gt;20)</span><br><span class="line">//            System.out.println(&quot;beautiful day&quot;);</span><br><span class="line">//        else</span><br><span class="line">//            System.out.println(&quot;cold day&quot;);</span><br><span class="line"></span><br><span class="line">        int income = 120_000;</span><br><span class="line">//boolean hasH ;</span><br><span class="line"></span><br><span class="line">//        if (income&gt;10_000)&#123;</span><br><span class="line">//           hasH=true;//花括号表示一个作用阈；1.如果定义变量需要加花括号 2.如果在外面读取花括号里面的东西是读不到的</span><br><span class="line">//        &#125;</span><br><span class="line">//        else</span><br><span class="line">//            hasH=false;</span><br><span class="line"></span><br><span class="line">//        boolean hasH = income&gt;10_000;</span><br><span class="line">//        System.out.println(hasH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//        d.三元运算</span><br><span class="line">//        String classNam;</span><br><span class="line">////        if (income &gt; 100_000) &#123;</span><br><span class="line">////            classNam = &quot;First&quot;;</span><br><span class="line">////        &#125;</span><br><span class="line">//</span><br><span class="line">//        classNam =income &gt;100_000 ? &quot;First&quot; :&quot;E&quot;//省去了if</span><br><span class="line"></span><br><span class="line">//        e.switch语句</span><br><span class="line">        String role = &quot;admin&quot;;</span><br><span class="line">//        if (role == &quot;admin&quot;) &#123;</span><br><span class="line">//            System.out.println(&quot;you are an admin&quot;);</span><br><span class="line">//        &#125; else if (role == &quot;moderator&quot;) &#123;</span><br><span class="line">//            System.out.println(&quot; u r moderator&quot;);</span><br><span class="line">//</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//        switch (role) &#123;</span><br><span class="line">//            case &quot;admin&quot;:</span><br><span class="line">//                System.out.println(&quot;you are an admin&quot;);</span><br><span class="line">//                break; //不使用break,它就会继续执行</span><br><span class="line">//            case &quot;moderator&quot;:</span><br><span class="line">//                System.out.println(&quot; u r moderator&quot;);</span><br><span class="line">//                break;</span><br><span class="line">//            default:</span><br><span class="line">//                System.out.println(&quot; u r gust&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//        f. for循环</span><br><span class="line">//        for (int i =0;i &lt;5 ;i++)&#123;</span><br><span class="line">//            System.out.println(&quot;heyyy &quot; +i);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//        ｇ．ｗｈｉｌｅ　循环</span><br><span class="line"></span><br><span class="line">//        int i =5;</span><br><span class="line">//        while (i&gt;0)&#123; //在不清楚会循环多少次时使用</span><br><span class="line">//            System.out.println(&quot;hey while&quot;);</span><br><span class="line">//            i --;</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">        String input = &quot;&quot;;</span><br><span class="line">//        while (input !=&quot;quit&quot;)&#123; //input是字符串</span><br><span class="line"></span><br><span class="line">        Scanner scanner = new Scanner(System.in);     //  创建一个扫描对象</span><br><span class="line">//        while (!input.equals(&quot;quit&quot;))&#123;  //因为是2个不同的字符串 所以他们的地址不一样，可以用equal比较</span><br><span class="line">////          Scanner scanner = new Scanner(System.in) ;     //  创建一个扫描对象 如果每次while都要创建一个 这会污染内存，所以把它放外面</span><br><span class="line">//            input = scanner.next().toLowerCase();</span><br><span class="line">//            System.out.println(input);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//        h.do while循环 至少会执行一次 即使条件为假</span><br><span class="line">//do&#123;</span><br><span class="line">//    System.out.println(&quot;Input:&quot;);</span><br><span class="line">//    input = scanner.next().toLowerCase();</span><br><span class="line">//    System.out.println(input);</span><br><span class="line">//</span><br><span class="line">//&#125;while (!input.equals(&quot;quit&quot;));</span><br><span class="line"></span><br><span class="line">//        i.break</span><br><span class="line"></span><br><span class="line">//                while (!input.equals(&quot;quit&quot;))&#123;  //因为是2个不同的字符串 所以他们的地址不一样，可以用equal比较</span><br><span class="line">//                    System.out.println(&quot;Input:&quot;);</span><br><span class="line">//            input = scanner.next().toLowerCase();</span><br><span class="line">//            if (input.equals(&quot;pass&quot;))</span><br><span class="line">//                continue;// 遇到此关键字 java会把控制移到循环的开始</span><br><span class="line">//            if (input.equals(&quot;quit&quot;))</span><br><span class="line">//                break;//当java看到break时它将终止循环 忽略其他所有内容</span><br><span class="line">//            System.out.println(input);</span><br><span class="line">//        &#125;</span><br><span class="line">//                当使用whiLe (true)语句时候 一定要保证花括号里有break语句否则它会一直循环下去</span><br><span class="line"></span><br><span class="line">//        j.foreach循环</span><br><span class="line">        String[] fruits = &#123;&quot;apple&quot;, &quot;mango&quot;, &quot;orange&quot;&#125;;</span><br><span class="line">//                for (int i =0;i&lt;fruits.length,i++)</span><br><span class="line">//        System.out.println(fruits[i]);</span><br><span class="line"></span><br><span class="line">        for (String fruit : fruits) //不需要定义开始的数，不需要定义自增</span><br><span class="line">            System.out.println(fruit);//此方法总是向前出发，上面的方法是可以自减的</span><br><span class="line"></span><br><span class="line">//运行代码 shift f10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node连接sqlyog</title>
      <link href="/2023/07/30/mySqlYog/"/>
      <url>/2023/07/30/mySqlYog/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gitee.com/yaspayne/qmwj">我的项目</a><br><a href="https://www.cnblogs.com/tangbohu2008/p/11177800.html#:~:text=1%E3%80%81%E6%89%93%E5%BC%80%E5%B7%A5%E5%85%B7%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%90%E6%96%B0%E5%BB%BA%E3%80%91%E8%BE%93%E5%85%A5%E5%90%8D%E7%A7%B0%E3%80%81%E7%94%A8%E6%88%B7%E5%90%8D%EF%BC%9Aroot%EF%BC%8C%E5%AF%86%E7%A0%81%E6%98%AF%E5%AE%89%E8%A3%85%E6%97%B6%E8%87%AA%E5%B7%B1%E8%AE%BE%E7%BD%AE%E7%9A%84%20%28%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%B0%E4%BD%8F%E7%9A%84%29%EF%BC%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7%E9%BB%98%E8%AE%A4%E6%98%AF%EF%BC%9A3306%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E8%BF%9E%E6%8E%A5%E3%80%82,2%E3%80%81%E7%82%B9%E5%87%BB%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F%E8%BF%9B%E5%85%A5%E5%90%8E%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A%203%E3%80%81%E5%9C%A8%E5%B7%A6%E8%BE%B9%E6%A8%A1%E5%9D%97%EF%BC%8C%E5%8F%B3%E5%87%BB%E9%80%89%E6%8B%A9%E3%80%90%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%EF%BC%9A">sqlyog 创建数据库连接 使用教程</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nodeMysql数据库</title>
      <link href="/2023/07/22/nodeMysql/"/>
      <url>/2023/07/22/nodeMysql/</url>
      
        <content type="html"><![CDATA[<p>1.下载mysql npm模块<br><code>npm i mysql --save</code><br>2.导入mysql模块<br>3.连接数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件结构</span><br><span class="line">src</span><br><span class="line">    -index.js</span><br><span class="line">    -router.js</span><br><span class="line">    -mysql.js</span><br></pre></td></tr></table></figure><ul><li><p>1.index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line">const router = require(&quot;./router&quot;);</span><br><span class="line"></span><br><span class="line">app.use(&quot;/&quot;, router);</span><br><span class="line">app.listen(4000, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;服务器开启了&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>2.router.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const router = express.Router();</span><br><span class="line">// 导入mysql模块</span><br><span class="line">const mysql = require(&quot;mysql&quot;);</span><br><span class="line">const content = mysql.createConnection(&#123;</span><br><span class="line">  host: &quot;localhost&quot;,</span><br><span class="line">  user: &quot;root&quot;,</span><br><span class="line">  password: &quot;123456&quot;,</span><br><span class="line">  database: &quot;&quot;, //数据库名称</span><br><span class="line">  port: &quot;3306&quot;, //端口号</span><br><span class="line">&#125;);</span><br><span class="line">router.get(&quot;/&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&quot;pl&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">// 接口 查看所有用户信息</span><br><span class="line">router.get(&quot;/&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  let sql = &quot;select * from userinfo&quot;;</span><br><span class="line">  content.query(sql, (error, result) =&gt; &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">      console.log(&quot;数据库操作失败&quot;);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 成功查询到数据 把结果返回给前端</span><br><span class="line">    res.send(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></li><li><p>3.mysql.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const mysql = require(&quot;mysql&quot;); //1.导入</span><br><span class="line">// 2.连接</span><br><span class="line">const content = mysql.createConnection(&#123;</span><br><span class="line">  host: &quot;localhost&quot;,</span><br><span class="line">  user: &quot;root&quot;,</span><br><span class="line">  password: &quot;123456&quot;,</span><br><span class="line">  database: &quot;&quot;, //数据库名称</span><br><span class="line">  port: &quot;3306&quot;, //端口号</span><br><span class="line">&#125;);</span><br><span class="line">// 3.编写sql语句</span><br><span class="line">const sql = &quot;select * from userinfo&quot;;</span><br><span class="line"></span><br><span class="line">// 4.执行sql语句 参数1：数据库查错误，数据库查成功</span><br><span class="line">content.query(sql, function (error, success) &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    console.log(&quot;数据库操作失败&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&quot;ok&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 如果想验真，直接node运行此页面就行</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node + express in 3 hours笔记</title>
      <link href="/2023/07/21/nodeexpress%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/21/nodeexpress%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ol><li>npm init &#x2F;&#x2F;项目初始化，创建package.json 配置文件</li><li>npm i express –save &#x2F;&#x2F;–save 模块会被保存到pacakge.json的dependence中 缩写 npm i -S<br> – save -dev&#x2F;&#x2F;下载的包会被保存到package.json的dev,只是开发环境需要 缩写：npm i -D<br> -g 全局安装<br>3.package-lock.json 是包的详细信息<br>4.安装cnpm<br> 1.npm i -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br> 2.检测 cnpm -v 不报错就ok<br>5.路由<br> -使用express的方法，导出，use<br> -文件结构: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">    -index.js</span><br><span class="line">    -router.js</span><br><span class="line">    -package.json</span><br><span class="line">public</span><br><span class="line">    -css</span><br><span class="line">        -reset.css</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    // 1.导入express的router功能</span><br><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line"></span><br><span class="line">// 2.创建路由器</span><br><span class="line">const router = express.Router();</span><br><span class="line"></span><br><span class="line">// 3.创建路由地址--配路由</span><br><span class="line">// router.get(&quot;/&quot;, (req, res) =&gt; &#123;</span><br><span class="line">//   res.send(&quot;首页接口数据&quot;);</span><br><span class="line">// &#125;);</span><br><span class="line">// 轮播接口</span><br><span class="line">router.get(&quot;/banner&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&quot;轮播接口数据&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 获取路由参数 get方法</span><br><span class="line">router.get(&quot;/&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  //req.query是前端传来的参数</span><br><span class="line">  // 后端可以定义接受变量名称</span><br><span class="line">  let user = req.query.username; //username是我定义的变量名</span><br><span class="line">  let pwd = req.passwaord;</span><br><span class="line">  console.log(req);</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    user,</span><br><span class="line">    pwd,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">// 获取路由参数 post方法 req.body获得，此外还要app.use(express.urlencoded(&#123;extendsd:true&#125;))这个中间件 编码</span><br><span class="line">router.post(&quot;/login&quot;, (req, res) =&gt; &#123;</span><br><span class="line">  let user = req.body.user;</span><br><span class="line">  if (user == &quot;admin&quot;) &#123;</span><br><span class="line">    user.code = 200;</span><br><span class="line">    res.send(user);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    user.code = 400;</span><br><span class="line">    res.send(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 导出路由模块</span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure> index.js: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">// 1.静态文件托管</span><br><span class="line">app.use(&quot;/&quot;, express.static(&quot;../public&quot;)); //把图片等文减价暴露出来 在get访问时就不必写public,直接/就能访问里面的东西 localhost:/8000/css</span><br><span class="line">// 2.路由模块化</span><br><span class="line"></span><br><span class="line">// 导入路由文件</span><br><span class="line">const router = require(&quot;./router&quot;);</span><br><span class="line"></span><br><span class="line">// /一级接口 /banner二级接口</span><br><span class="line">// app.use(&quot;/api&quot;, router); //访问localhost/api/路径地址才能访问的router文佳里的东西</span><br><span class="line"></span><br><span class="line">// post 请求处理的中间件</span><br><span class="line">app.use(express.urlencoded(&#123; extended: true &#125;)); //</span><br><span class="line"></span><br><span class="line">// 使用这个路由 app.use(&#x27;/根路径&#x27;,资源)</span><br><span class="line">app.use(&quot;/&quot;, router);</span><br><span class="line"></span><br><span class="line">// 开启服务器</span><br><span class="line">app.listen(80, () =&gt; &#123;</span><br><span class="line">  console.log(&quot;服务器开启了&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>6.express 处理get请求<br> 引入index.js时，app.use(‘&#x2F;这个路由文件的跟路径’,暴露出来的对象)<br>7.get请求传参<br> router方法的req.query是前端传来的参数<br> post方法 req.body获得，此外还要app.use(express.urlencoded({extendsd:true}))这个中间件 编码<br>8.静态文件托管<br> app.use(“&#x2F;“, express.static(“..&#x2F;public”)); &#x2F;&#x2F;访问图片等<br>9.连接数据库</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node 1小时速成课</title>
      <link href="/2023/07/21/nodecrash1hour2/"/>
      <url>/2023/07/21/nodecrash1hour2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// console.log(module);</span><br><span class="line">// 1.使用我导出的</span><br><span class="line">// 导入</span><br><span class="line">// const logger=require(&#x27;./logger&#x27;)</span><br><span class="line">// console.log(logger);</span><br><span class="line">// logger.log(&#x27;woaini&#x27;)</span><br><span class="line">// console.log(__filename);</span><br><span class="line">// console.log(__dirname);</span><br><span class="line">// 2.使用path模块 获得路径</span><br><span class="line">// const path=require(&#x27;path&#x27;);</span><br><span class="line">// var pathObj=path.parse(__filename)</span><br><span class="line">// console.log(&#x27;pathObj: &#x27;, pathObj);</span><br><span class="line">// 3.获取操作系统</span><br><span class="line">// const os =require(&#x27;os&#x27;)</span><br><span class="line">// const totalmen=os.totalmem()</span><br><span class="line">// console.log(&#x27;totalmen: &#x27;, totalmen);</span><br><span class="line">// 4.fs 文件系统</span><br><span class="line">// const fs=require(&#x27;fs&#x27;)</span><br><span class="line">// const files=fs.readdirSync(&#x27;./&#x27;) //同步 阻塞的</span><br><span class="line">// console.log(&#x27;files: &#x27;, files);</span><br><span class="line">// 异步</span><br><span class="line">// fs.readdir(&#x27;￥&#x27;,function (err,files) &#123;</span><br><span class="line">//     if (err) console.log(&#x27;Error&#x27;,err)</span><br><span class="line">//     else console.log(&#x27;result&#x27;,files);</span><br><span class="line">// &#125;)</span><br><span class="line">// 5.events 事件模块</span><br><span class="line">// const EventEmitter=require(&#x27;events&#x27;) //大驼峰书写 表示这是一个class :is a contaiber of a bunch of methods</span><br><span class="line">// const emitter=new EventEmitter(); //class is huamna,object is mary</span><br><span class="line">// // 创建一个listner</span><br><span class="line">// emitter.on(&#x27;messageLogged&#x27;,function (params) &#123;</span><br><span class="line">//     console.log(&#x27;lister called&#x27;,params);</span><br><span class="line">// &#125;)</span><br><span class="line">// emitter.emit(&#x27;messageLogged&#x27;,&#x27;雨晴辛苦了&#x27;)</span><br><span class="line">// 6.定义一个class</span><br><span class="line">// class Logger extends EventEmitter&#123;</span><br><span class="line">// log(message)&#123;</span><br><span class="line">//     console.log(&#x27;message: &#x27;, message);</span><br><span class="line">// // emitter.emit(&#x27;messageLogged&#x27;,&#x27;雨晴辛苦了&#x27;)</span><br><span class="line">// this.emit(&#x27;messageLogged&#x27;,&#x27;雨晴辛苦了&#x27;)</span><br><span class="line">// &#125;&#125;</span><br><span class="line"></span><br><span class="line">// module.exports=Logger //导出class</span><br><span class="line">// 7.HTTP模块</span><br><span class="line">// const http=require(&#x27;http&#x27;)</span><br><span class="line">// const server=http.createServer()</span><br><span class="line">// server.on(&#x27;connection&#x27;,()=&gt;&#123;</span><br><span class="line">//     console.log(&#x27;NEW CONNECTION.....&#x27;);</span><br><span class="line">// &#125;)</span><br><span class="line">// const server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">//     //req是请求对象，包含了与客户端相关的数据和属性 </span><br><span class="line">//     //req.url是客户端请求路径 req.method是客户端请求的method类型</span><br><span class="line">//     if(req.url===&#x27;/&#x27;)&#123;</span><br><span class="line">//         res.write(&#x27;heyyy&#x27;);</span><br><span class="line">//         res.end() //向客户端响应一些内容,并结束这次请求</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;)</span><br><span class="line">// const server=http.createServer((req,res)=&gt;&#123;</span><br><span class="line">//     console.log(&#x27;url&#x27;,req.url,&#x27;method&#x27;,req.method);</span><br><span class="line">// res.end(&#x27;url&#x27;)</span><br><span class="line">// &#125;)</span><br><span class="line">// server.listen(3000) //启动服务器的方法</span><br><span class="line">// console.log(&#x27;listening on port http://127.0.0.1&#x27;);</span><br><span class="line"></span><br><span class="line">// 8.commentJs 规范</span><br><span class="line">// a。module变量代表当前模块</span><br><span class="line">// b.moudule变量是一个对象，moudule.exports 是对外接口</span><br><span class="line">// c.加载模块用require方法</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向日程表开发</title>
      <link href="/2022/12/17/myprojMp/"/>
      <url>/2022/12/17/myprojMp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>微信搜索<code>逆向日程</code>或<code>逆向日程表</code>即可找到小程序<br><a href="https://gitee.com/yaspayne/reverse-schedule">项目源码</a></p></blockquote><h2 id="1-开发背景"><a href="#1-开发背景" class="headerlink" title="1.开发背景"></a>1.开发背景</h2><p><a href="https://www.bilibili.com/video/BV1cP4y1A72R">逆向日程表的社会科学背景</a></p><p>逆向日程表以 30 分钟的番茄钟时间为目标，完成即可完成计划。以最想做的计划，有心流的事为优先的一种规划事件的方法</p><p><a href="https://www2.jianshu.com/p/57978b77cb9b">逆向日程的来源</a></p><h2 id="2-小程序引入图表数据工具-uchart"><a href="#2-小程序引入图表数据工具-uchart" class="headerlink" title="2.小程序引入图表数据工具 uchart"></a>2.小程序引入图表数据工具 uchart</h2><p>使用 DCloud 插件市场定制的 uchart 插件即可，配置方法与 echart 相同</p><p>在<strong>ops</strong>对象中通过修改属性值设置饼图的颜色、边框、透明度等样式</p><p>把储存在本地的日程信息获取后赋值给在<strong>chartData</strong>的 res.series.data;<br>在使用过程中发现 res.series.data 数组对象需要重新定义 var 变量赋值才会获取到实际的变量的值</p><h2 id="3-设置事件优先级的颜色"><a href="#3-设置事件优先级的颜色" class="headerlink" title="3.设置事件优先级的颜色"></a>3.设置事件优先级的颜色</h2><p>本次开发使用的是 uni ui 组件并没有符合设计要求的点击切换事件栏颜色的 ui 组件，所以使用三目运算嵌套控制颜色改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:style=&quot;item.type === 1 ? &#x27;background-color:#94bcff;&#x27; : (item.type === 2 ? &#x27;background-color:#8cde9b;&#x27; : &#x27;background-color:#ffffff;&#x27;)&quot;</span><br></pre></td></tr></table></figure><h2 id="4-在开发过程中遇到-tableData-length-不是-function-的错误提示"><a href="#4-在开发过程中遇到-tableData-length-不是-function-的错误提示" class="headerlink" title="4.在开发过程中遇到 tableData.length 不是 function 的错误提示"></a>4.在开发过程中遇到 tableData.length 不是 function 的错误提示</h2><p>原因是第一次在写入数组对象的值的过程中数组被转换成类数组，所以使用数组方法会报错，解决方法是使用<br>Array.from()方法</p><p><code>this.tableData = Array.from(this.tableData)</code></p><h2 id="5-使用-uni-ui-组件在-chrome-模拟器能改变样式而在微信开发者平台模拟的样式并没有改变"><a href="#5-使用-uni-ui-组件在-chrome-模拟器能改变样式而在微信开发者平台模拟的样式并没有改变" class="headerlink" title="5.使用 uni ui 组件在 chrome 模拟器能改变样式而在微信开发者平台模拟的样式并没有改变"></a>5.使用 uni ui 组件在 chrome 模拟器能改变样式而在微信开发者平台模拟的样式并没有改变</h2><p>在开发者平台点击箭头查看样式 style 找到 uniui 组件的 class 名 再在自写的代码中使用 css 选择器:nth-child(2n)选中改变事件栏的样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.uni-table-td:nth-child(2n) &#123;</span><br><span class="line">padding: 8rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS题目</title>
      <link href="/2022/11/18/interviewqs2/"/>
      <url>/2022/11/18/interviewqs2/</url>
      
        <content type="html"><![CDATA[<h2 id="判断一个-js-变量-x-是不是数组的方法？"><a href="#判断一个-js-变量-x-是不是数组的方法？" class="headerlink" title="判断一个 js 变量 x 是不是数组的方法？"></a>判断一个 js 变量 x 是不是数组的方法？</h2><ul><li>1.打印 变量 x.prototype.toString()<br>如果打印为[object Array]，则 x 是数组</li><li>2.打印 变量 x.constructor&#x3D;&#x3D;Array，如果打印为 true 则 x 是数组</li><li>3.打印 变量 x instanceof array 判断，如果打印为 true 则 x 是数组</li></ul><h2 id="请回答下列代码执行结果，并标出-console-log-的执行顺序。"><a href="#请回答下列代码执行结果，并标出-console-log-的执行顺序。" class="headerlink" title="请回答下列代码执行结果，并标出 console.log 的执行顺序。"></a>请回答下列代码执行结果，并标出 console.log 的执行顺序。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(function a() &#123;</span><br><span class="line">  let i = 1;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    i++;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve(2);</span><br><span class="line">  &#125;).then(function (res) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(i + ~~!!i);</span><br><span class="line">    &#125;, 10);</span><br><span class="line">    i = 3;</span><br><span class="line">    console.log(res);</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();//打印结果1，2，3，4，5</span><br></pre></td></tr></table></figure><ul><li><p>打印顺序</p><ul><li>1 console.log(1);</li><li>2 console.log(res);</li><li>3 console.log(i);</li><li>4 console.log(i + ~~!!i);</li><li>5 console.log(i);</li></ul></li></ul><h3 id="是转换成布尔值的意思，-是取整的意思"><a href="#是转换成布尔值的意思，-是取整的意思" class="headerlink" title="!!是转换成布尔值的意思，~~是取整的意思"></a>!!是转换成布尔值的意思，~~是取整的意思</h3><p>一整个函数先执行 promise 异步运算.传 resolve 的情况， 那么 promise 下一步执行 then 方法 ,resolve 刚刚传了一个参数 2</p><ol start="3"><li><p>jQuery 的美元符号$有什么作用？<br> $只是”jQuery”的别名，它是 jQuery 的选择器<br>也可以用 jQuery 来代替$，如下代码：<br>jQuery(document).ready(function(){<br>});</p></li><li><p>请使用 jQuery 将页面上的所有元素边框设置为 2px 宽的虚线？</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">$(&quot;*&quot;).css(&quot;border&quot;, &quot;2px dotted red&quot;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li><p>body 中的 onload()函数和 jQuery 中的 document.ready()有什么区别？<br>我们可以在页面中使用多个 document.ready()，但只能使用一次 onload()。</p></li><li><p>选择器的 change 事件<br><code>$(&quot;.check&quot;).cahnge(function())</code></p></li><li><p>用 jquey 查看输入框是否被选中<br><code>$(&quot;.check&quot;).prop(&quot;checked&quot;,true)</code></p></li><li><p>实现一个全选中，其他也全选中</p></li></ol><ul><li>props 可以改变输入框选择的属性<br><code>$(&quot;.check&quot;).prop(&quot;checked&quot;,$(&quot;this&quot;).prop(&quot;checked&quot;))</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript笔记</title>
      <link href="/2022/10/03/jsqs2/"/>
      <url>/2022/10/03/jsqs2/</url>
      
        <content type="html"><![CDATA[<h2 id="js-面试相关-2"><a href="#js-面试相关-2" class="headerlink" title="js 面试相关 2"></a>js 面试相关 2</h2><ol><li>JS 数据类型</li></ol><ul><li>基本数据类型有<br>String<br>Number<br>boolean<br>Undefined<br>Null<br>Symbol</li><li>引用数据类型有<br>Object<br>Array<br>function</li></ul><ol start="2"><li><p>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;有什么区别？</p><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>是赋值运算符</td></tr><tr><td>&#x3D;&#x3D;</td><td>是等于操作符，可以进行一次类型转换比较值是否相等</td></tr><tr><td>&#x3D;&#x3D;&#x3D;</td><td>是严格全等操作符，如果数据类型不相同，直接返回 false，值</td></tr></tbody></table></li><li><p>什么是堆栈？<br>堆栈是个简单的数据存储结构，是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。</p></li><li><p>深拷贝和浅拷贝的区别</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象</td><td>ff</td></tr><tr><td>深拷贝把要复制的对象所引用的对象都复制了一遍</td><td>所以是{…data[0]}</td></tr></tbody></table></li><li><p>闭包解决了什么问题<br>闭包可以让你在内层函数中访问到外层函数的 作用域。<br>就是函数变量跨过自己的作用域，用上级作用域的变量的行为。<br>使用场景是 一些需用复用函数的地方<br>闭包让你可以在一个内层函数中访问到其外层函数的作用域<br>使用场景<br>• 创建私有变量<br>• 延长变量的生命周期</p></li><li><p>闭包导致了什么问题<br>一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p></li></ol><ul><li>导致内存泄漏<br>用动态存储分配函数内存空间，在使用完毕后未释放，导致一直占据该内存单元。<br>bar 函数内部进行了访问，并且根据垃圾回收机制，被另一个作用域引用的变量不会被回收。除非 bar 函数解除调用才能销毁。（就是里面的函数不被解决，内存回一直存在占用内存单元）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript知识</title>
      <link href="/2022/10/02/jsqs/"/>
      <url>/2022/10/02/jsqs/</url>
      
        <content type="html"><![CDATA[<ul><li>背景<br>在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</li></ul><ol><li>什么是构造函数</li></ol><p>是用 new 关键字创建，并且首字母大写，本质上也是个函数,例如<br><code>var obj = new Person(&#39;enfp&#39;，18);</code></p><ol start="2"><li><p>什么是原型<br>当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。</p></li><li><p>什么是原型链<br>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型对象可能也拥有原型,并从中继承方法和属性，一层一层，以此类推，这种关系被称为原型链。</p></li><li><p>什么是作用域<br>能在一定空间里可以对数据进行读写操作，这个空间就是数据的作用域。</p></li><li><p>什么是作用域链<br>当在 js 中使用一个变量的时候，js 会在当前作用域下寻找该变量，如果没找都，它回到它的上层作用域寻找，直到找到该变量或或者是找到全局作用域。</p></li><li><p>什么是闭包<br>闭包可以让你在内层函数中访问到外层函数的 作用域。<br>就是函数变量跨过自己的作用域，用上级作用域的变量的行为。</p></li><li><p>ES6 有哪些新特性</p><table><thead><tr><th>编号</th><th>内容</th></tr></thead><tbody><tr><td>1</td><td>ES6 新增一种数据类型 symbol</td></tr><tr><td>2</td><td>新增两个声明变量的关键字 let const.它们不会在预编译中有提升行为</td></tr><tr><td>3</td><td>解构赋值，let [a,b,c]&#x3D;[1,2,3]像这样是对赋值运算符的拓展</td></tr><tr><td>4</td><td>新增了箭头函数，解决了函数关键字声明的麻烦</td></tr></tbody></table></li><li><p>什么是回调地狱<br>常常第一个的函数的输出是第二个函数的输入这种现象</p></li><li><p>什么是 promise<br>是异步编程的解决方案，有三种状态 pending(等待态)、fulfiled（成功态）、reject(失败态)用来解决回调地狱，解决异步问题</p></li><li><p>怎么使用 promise<br>Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数<br>在自己手写后台时匹配数据库时，根据数据库 有没有报错给它选择 then 还是 catch</p></li><li><p>什么是 Promise.all?<br>Promise.all(promisesArrayOrIterable) 帮助我们一次，并行处理多个 promise, 然后将结果聚合到一个数组里边，这是聚合结果，不是说返回结果哦。<br>如果所有 promise 都成功解析，Promise.all() 会将每个 promise 的已完成值 聚合 到数组。我们可以按照原来参数中每一个 promise 的顺序，获取到他们对应的完成值。<br>如果有其中一个 promise 被拒绝，那么 Promise.all() 会以同样的原因立即拒绝（不等待其他 Promise 解决）。</p></li><li><p>什么是冒泡事件？<br>事件会向这个对象的的父级传播，从里到外，直至它被处理</p></li><li><p>什么是事件委托&#x2F;事件代理？<br>事件委托就是把原本需要绑定在子元素上的事件（onclick、onkeydown 等）委托给它的父元素，让父元素来监听子元素的冒泡事件</p></li><li><p>为什么 0.1+0.2 不等于 0.3<br>因为计算机运行过程中，需要将数据转化成二进制，然后再进行计算。js 中的 Number 类型遵循 IEEE754 标准，在 IEEE754 标准的 64 位浮点数相加，因为浮点数自身小数位数的限制而截断的二进制在转化为十进制，就变成 0.30000000000000004，所以在计算时会产生误差。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue项目中使用百度地图接口</title>
      <link href="/2022/09/10/mapqs/"/>
      <url>/2022/09/10/mapqs/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-项目中使用百度地图接口"><a href="#vue-项目中使用百度地图接口" class="headerlink" title="vue 项目中使用百度地图接口"></a>vue 项目中使用百度地图接口</h2><ol><li>注册百度地图的开发者帐号并拿到密钥</li><li>简单应用地图<br>引入<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://api.map.baidu.com/api?v=1.0&amp;type=webgl&amp;ak=您的密钥&quot;&gt;</code></li></ol><p>创建地图实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var map = new BMapGL.Map(&quot;container&quot;);// 创建地图实例</span><br><span class="line">   var point = new BMapGL.Point(116.404, 39.915);// 创建点坐标</span><br><span class="line">   map.centerAndZoom(point, 15);// 初始化地图，设置中心点坐标和地图级别</span><br></pre></td></tr></table></figure><blockquote><p>参考 <a href="https://blog.csdn.net/TeAmo__/article/details/123901089">https://blog.csdn.net/TeAmo__/article/details/123901089</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>soundfy开发</title>
      <link href="/2022/08/17/myproj2/"/>
      <url>/2022/08/17/myproj2/</url>
      
        <content type="html"><![CDATA[<p>###1.搜索页面仿照 spotify 搜索页面</p><blockquote><p><a href="https://gitee.com/yaspayne/soundfy">项目源码</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS问题2</title>
      <link href="/2022/05/23/machinetest1/"/>
      <url>/2022/05/23/machinetest1/</url>
      
        <content type="html"><![CDATA[<h2 id="某表单公司机试题"><a href="#某表单公司机试题" class="headerlink" title="某表单公司机试题"></a>某表单公司机试题</h2><h2 id="1-数据排序"><a href="#1-数据排序" class="headerlink" title="1.数据排序"></a>1.数据排序</h2><p>假设有如下字符串“A12”，其中“A”表示数据类型(A-Z) ，“12”表示数据序号(0-9) 。现在需要对一组数据先按照数据序号再按照数据类型进行排序。<br>例如: [“B3”,”D2”,”F1”,”A9”,”D12”,”A2”,”C1”,”Z0’”,”B1”]&#x3D;&gt;[“Z0”,”B1”,”C1”,”F1”,”A2”,”D2”,”B3”,”A9”,”D12”]</p><p>我的答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var unorderData = [&quot;B3&quot;, &quot;D2&quot;, &quot;F1&quot;, &quot;A9&quot;, &quot;D12&quot;, &quot;A2&quot;, &quot;C1&quot;, &quot;Z0&quot;, &quot;B1&quot;];</span><br><span class="line">// 排序结果</span><br><span class="line">var orderedData = unorderData.sort().sort(function (a, b) &#123;</span><br><span class="line">  return a.slice(1) - b.slice(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-局部页面实现（必答题）"><a href="#2-局部页面实现（必答题）" class="headerlink" title="2. 局部页面实现（必答题）"></a>2. 局部页面实现（必答题）</h2><p>页面设计图：点此查看<a href="https://www.figma.com/file/TpilpjXkaDUOw6sm1EogqP/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80?node-id=0:1&t=ueel6JWr5T0P2UZK-0">设计图</a><br>请实现以上设计图中的页面内容。要求：</p><ol><li>一比一还原设计图</li><li>不可以使用 table</li><li>最小支持页面宽度为：1024px</li></ol><ul><li>使用了 flex 嵌套布局实现表单样式，justify-content 实现一行 item 在水平方向的对齐；align-item 实现一列 item 在竖直方向上的对齐。</li><li>class 类 CSS 样式复用</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS中的this关键词</title>
      <link href="/2022/05/15/thisqs/"/>
      <url>/2022/05/15/thisqs/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解-JS-中的-this-关键词"><a href="#如何理解-JS-中的-this-关键词" class="headerlink" title="如何理解 JS 中的 this 关键词"></a>如何理解 JS 中的 this 关键词</h2><ul><li>this 表示当前对象的一个引用,代表函数运行时，自动生成的一个内部对象,JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变</li></ul><ol><li>全局作用域下-this 默认指向 window,在浏览器中测试可知，全局作用下 this 指向是指向 window</li><li>直接调用普通函数-this 指向 window 对于直接调用普通函数，this 的指向一定是 window</li><li>通过对象调用函数-谁调用函数，this 指向谁</li><li>显式绑定-bind、call、apply 显式绑定后，this 会明确的指向绑定对象</li><li>调用 new 关键词创建的对象实例的函数<br>构造函数或 Class 类，可以通过 new 关键词创建的对象实例，这时 this 永远的指向了实例化的对象上面</li><li>ES6 中箭头函数（()&#x3D;&gt;{}）没有 this、arguments、super 等，不受上边的规则限制，这些只依赖包含箭头函数最接近的函数中的规则，也就是外层作用域来决定 this。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue知识1</title>
      <link href="/2022/02/01/vueqs2/"/>
      <url>/2022/02/01/vueqs2/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-知识"><a href="#vue-知识" class="headerlink" title="vue 知识"></a>vue 知识</h2><ol><li><p>可以把一些简单的 js 指令放在 v-on 里面<br><code>&lt;button v-on :click=&quot;counter +=1 &quot;&gt;Add 1&lt;/button&gt; </code><br><code>&lt;el-button type=&quot;primary&quot; @click=&quot;innervisibleImg = true&quot;&gt;上传图片&lt;/el-button&gt;</code></p></li><li><p>vue 的生命周期<br>生命周期就是从摇篮到坟墓的整个过程，在 Vue 中实例从创建到销毁的过程，即指从创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线。<br>Vue 生命周期总共可以分为 8 个阶段:创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期.<br>生命周期有哪些</p></li></ol><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate,created</td><td>组件实例被创建之初,组件实例已经完全创建</td></tr><tr><td>beforeMount,mounted</td><td>组件挂载之前,组件挂载到实例上去之后</td></tr><tr><td>beforeUpdate,updated</td><td>组件数据发生变化，更新之前,组件数据更新之后</td></tr><tr><td>beforeDestroy,destroyed</td><td>组件实例销毁之前,组件实例销毁之后</td></tr><tr><td>activated</td><td>keep-alive 缓存的组件激活时</td></tr><tr><td>deactivated</td><td>keep-alive 缓存的组件停用时调用</td></tr><tr><td>errorCaptured</td><td>捕获一个来自子孙组件的错误时被调用</td></tr></tbody></table><ol start="3"><li><p>VUE 中如何避免样式冲突？<br>使用 scope 和 组件模块化</p></li><li><p>v-if 和 v-show 的区别？</p><ul><li>v-if 是根据它其后跟的条件是否为真来决定是否渲染，内容只会在指令的表达式返回 trut 值的时候被渲染.v-if 是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译;</li><li>v-show 是已经渲染出来，用样式控制是否可见的,用于根据条件展示元素的选项是 v-show 指令(频繁切换时使用)<br>v-show 是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，只是简单地切换元素的 CSS property display</li></ul></li><li><p>Vue2 怎么监听响应数据变化<br>在 vue2.x 版本中，数据监听是用过 Object.defineProperty 这个 API 来实现的<br>我们访问或设置对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值。<br>我们当然可以在触发函数的时候做我们自己想做的事情，这也就是“劫持”操作<br>在 Vue 中其实就是通过 Object.defineProperty 来劫持对象属性的 setter 和 getter 操作，并创建一个监听器，当数据发生变化的时候发出通知。</p></li><li><p>怎么理解 Vue 的 key?</p><p>key 就是一个标识，被使用在 Vue 中。再详细一点，key 被使用在 Vue 中的虚拟 DOM 中 1.只做数据展示用，不写 key 是没有任何影响的;<br>2.key 不会出现在真实 DOM 中<br>key 是给每一个 vnode(虚拟节点)的唯一 id，也是 vue 的 diff 算法（是一种逻辑）的一种优化策略。可以根据 key，更准确，更快的找到对应的 vnod 节点</p></li><li><p>VUE 的 nexttrick<br>如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新 10 万次视图)，有了 nextTick 机制，只需要更新一次，所以 nextTick 本质是一种优化策略</p></li><li><p>$router和$route 的区别</p><ul><li>Rotuer 是一个实列，用来实现路由跳转、操作路由<br>this.$router.push 等</li><li>route 获取当前路由的信息的，查看数据的详情</li></ul></li><li><p>什么是 Virtual DOM<br>Virtual DOM 是一种可以预先通过 JavaScript 进行各种计算，把最终的 DOM 操作计算出来并优化，由于这个 DOM 操作属于预处理操作，并没有真实的操作 DOM，所以叫做虚拟 DOM</p></li><li><p>为什么要选择 vue.js 它解决了什么问题</p><p>Vue 有声明式，响应式的数据绑定，与组件化的开发，并且还使用了 Virtual DOM,使用了 mvvm 模式，实现了双向绑定，使数据和视图的更新更为流畅，让前端应用程序开发方便。<br>它用来构建用户界面,Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。<br>引入 Virtual DOM 会加大 Vue.js 本身的代码尺寸，也会消耗更多内存和 CPU（会更耗电）</p><blockquote><p><a href="https://www.jianshu.com/p/6307e4ed4cf4">https://www.jianshu.com/p/6307e4ed4cf4</a></p></blockquote></li><li><p>Vue.js 中组件是如何通信的</p></li></ol><table><thead><tr><th>通信方法</th><th>详细</th></tr></thead><tbody><tr><td>props 父传子</td><td>父组件在子的标签中通过字面量传递值，子组件设置[‘props’]属性来接收</td></tr><tr><td>$emit 子传父</td><td>子组件用$emit 触发，第二个参数就是要传的值父组件 绑定监听器获取子组件传来的参数</td></tr><tr><td>Vuex</td><td>用于复杂关系的组件数据传递,vuex 相当于一个储存共享变量的容器</td></tr></tbody></table><ul><li>State :存放共享变量</li><li>Getter:store 中的计算属性，获取共享变量的值</li><li>Mutations:存放修改 state 的方法</li><li>Actions:异步修改 state</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack使用</title>
      <link href="/2022/01/14/webpackqs/"/>
      <url>/2022/01/14/webpackqs/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-使用"><a href="#webpack-使用" class="headerlink" title="webpack 使用"></a>webpack 使用</h2><pre><code>webpack是用来打包的,打包好放在dist文件夹里。</code></pre><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>上面讲到的前端这些新的技术，其实是无法直接运行源码的，必须通过转换后才能正常运行。另一方面，现在前端工程师需要维护的代码变得及为庞大和复杂，代码维护、打包、发布等流程也变得极为繁琐，同时浪费的时间和精力也越来越多，当然人为的错误也随着流程的增加而增加了更多的出错率。致使每一个团队都希望有一种工具，能帮助整个团队在开发中能精简流程、提高效率、减少错误率。</p><p>grunt、gulp、webpack、Parcel、vite 都是常见的打包工具</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>·代码转换:TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。<br>·文件优化:压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。<br>·代码分割:提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。<br>·模块合并:在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。·自动刷新:监听本地源代码的变化，自动重新构建、刷新浏览器。<br>·代码校验:在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。<br>·自动发布:更新完代码后，自动构建出线上发布代码并传输给发布系统。</p><h3 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h3><ol><li>在项目文件夹中安装 webpack<br><code>npm i -D webpack webpack-cli</code></li></ol><blockquote><p>npm i -D 为 npm install –save-dev 的缩写<br>npm i -s 为 npm install –save 的缩写</p></blockquote><ol start="2"><li><p>新建一个文件夹 src ,然后新建一个文件 main.js,写一点代码测试一下<br><code>console.log( &#39;Hello world&#39;)</code></p></li><li><p>配置 package.json 命令</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;build&quot; :&quot;webpack ./src/main.js&quot;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>执行 npm run build<br>此时如果生成了一个 dist 文件夹，并且内部含有 main.js 说明已经打包成功了.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cookie是什么</title>
      <link href="/2022/01/01/cookieqs/"/>
      <url>/2022/01/01/cookieqs/</url>
      
        <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie 类型为小型文本文件，是某些网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密），cookie 出现就是来弥补 HTTP 无状态的问题的，Cookie 可以作为一个状态保存的状态机，用来保存用户的相关登录状态</p><blockquote><p>cookie 和 token 的区别 <a href="https://juejin.cn/post/7111349594625146887">https://juejin.cn/post/7111349594625146887</a></p></blockquote><h2 id="cookie-储存形式"><a href="#cookie-储存形式" class="headerlink" title="cookie 储存形式"></a>cookie 储存形式</h2><p>Cookie 以名&#x2F;值对形式存储 username&#x3D;John Doe，当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。</p><h2 id="在-VUE-中使用-cookie"><a href="#在-VUE-中使用-cookie" class="headerlink" title="在 VUE 中使用 cookie"></a>在 VUE 中使用 cookie</h2><ul><li>1 安装<br><code>npm install vue-cookies --save</code></li><li>2 引入</li><li>3 设置全局配置，设置 cookie 过期时间和 url</li><li><a href="https://www.jianshu.com/p/60c13168cc8f">https://www.jianshu.com/p/60c13168cc8f</a></li></ul><h2 id="session-是什么"><a href="#session-是什么" class="headerlink" title="session 是什么"></a>session 是什么</h2><p>客户端请求服务端，服务端（Tomcat）会为这次请求开辟一块内存空间，这个对象便是 Session 对象， 存储结构为 ConcurrentHashMap。</p><p>session 的目的：弥补 HTTP 无状态特性，服务器可以利用 session 存储客户端在同一个会话期间的一些操作记录。</p><h2 id="vue-使用-session"><a href="#vue-使用-session" class="headerlink" title="vue 使用 session"></a>vue 使用 session</h2><blockquote><p><a href="https://www.cnblogs.com/instead-everyone/p/14611589.html">https://www.cnblogs.com/instead-everyone/p/14611589.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>封装前端请求头</title>
      <link href="/2022/01/01/axiosapiqs/"/>
      <url>/2022/01/01/axiosapiqs/</url>
      
        <content type="html"><![CDATA[<h2 id="封装前端请求头"><a href="#封装前端请求头" class="headerlink" title="封装前端请求头"></a>封装前端请求头</h2><ul><li>1.引入 axios 安装包对象 npm 包</li><li>2.新建 Utils&#x2F;axios.js</li><li>3.在里面自定义配置新建一个实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const instance = axios.create(&#123; baseURL: &#x27;https://some-domain.com/api/&#x27;, timeout: 1000, headers: &#123;&#x27;X-Custom-Header&#x27;: &#x27;foobar&#x27;&#125; &#125;);</span><br></pre></td></tr></table></figure><ul><li>4.配置请求拦截器对象.属性和对象[‘属性’]这两个用法的意义其实是一样的，都是用来调用对象的属性。config 里面就包括请求头，在这里统一配一个请求头</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(config =&gt;&#123;console.log(config)</span><br><span class="line">let token = sessionstorage.getItem( &#x27;mytoken&#x27;);</span><br><span class="line">//从浏览器中，获取token的值</span><br><span class="line">token &amp;&amp;(config.headers[ &#x27;token&#x27;] = token);</span><br><span class="line">//自己添加一个token到Headersreturn config;</span><br><span class="line">//少写一行代码,则不能实现axios接口调用。</span><br><span class="line">&#125;, error =&gt; Promise.reject(error));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>5.设置响应拦截器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(response=&gt;i</span><br><span class="line">console.log(response)</span><br><span class="line">//先观察响应对象的SON结构，怎么样可以拿到token?下一行就相应的进行修改</span><br><span class="line">response.data.token &amp;&amp; sessionStorage.setItem(&#x27;mytoken&#x27;, response.data.token);</span><br><span class="line">return response.data;</span><br><span class="line">//决定了在调用接口时，如何获取到数据，如何判断是否调用成功。&#125;,</span><br><span class="line">error=&gt;&#123;</span><br><span class="line">let res = error.response;</span><br><span class="line">switch(res.status)&#123;</span><br><span class="line">// http请求的状态码，其中401，代表token认证失败。case 401:</span><br><span class="line">sessionstorage.removeItem( &#x27; mytoken &#x27;);</span><br><span class="line">// return router.push(&quot;/login&quot; )</span><br><span class="line">//跳转到登录页面</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>6.在 main.js 中引入刚刚封装的 axios</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Axios from &#x27;./util/axios.js &#x27;</span><br><span class="line">Vue.prototype.$axios = Axios;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何用和弦写一首歌</title>
      <link href="/2022/01/01/howtowritesong/"/>
      <url>/2022/01/01/howtowritesong/</url>
      
        <content type="html"><![CDATA[<h2 id="如何用和弦写一首歌"><a href="#如何用和弦写一首歌" class="headerlink" title="如何用和弦写一首歌"></a>如何用和弦写一首歌</h2><ul><li>你今天想抒发一下情感</li></ul><ol><li><p>确定这首歌想表达什么氛围，讲述什么故事<br>找出几个或一个关键词，是困惑、厌恶、分手、喜欢的女孩&#x2F;男孩、糟糕的一天、嫉妒？。。。</p><ul><li>让这些关键词变成一个具体的话,写下来<br>天气清凉、空气干燥<br>最好的感觉<br>Ta 们对我一点都不了解<br>my first time crushing</li></ul></li><li><p>选一个当下符合自己故事&#x2F;心情的和弦进行</p><ul><li>乐器</li><li>没有乐器，或者不会乐器，可以试试<a href="https://chordchord.com/">chordchord 和弦网站</a><br>让 Ta 们循环起来<br>我喜欢，目前会的有 C→A→F→G</li></ul></li><li><p>旋律<br>在循环和弦进行的时候，唱一个音节出来，怕走调的话，可以先听听和弦里的每一个单音<br>这个哼唱自然延续，用你脑袋里想到的任何旋律、说话的声音。</p><ul><li>可以试着向上的旋律 ↑</li><li>可以是向下的 ↓</li><li>组合任何事物<br>录下来:D</li></ul></li><li><p>结构<br>一首歌常见，经久不衰的结构是<br>verse1→pre-chorus→chorus→verse2→pre-chorus→chorus</p></li><li><p>构建完整的歌词</p><ul><li>读诗歌</li><li>听觉得适合的歌单<br>一个词一个词地把它们写下来，experience–<br>copycat AKa 临摹</li></ul></li><li><p>用任何一个 DAW 软件录下来<br>发表到哔哩哔哩，网易云音乐、QQ 空间。。</p><blockquote><p>本文是对 Annie Dang 的视频的文字整理<br>录音 <a href="https://youtu.be/lOAETrx2pXk">https://youtu.be/lOAETrx2pXk</a><br>写歌 <a href="https://youtu.be/Q3lCmRzceg">https://youtu.be/Q3lCmRzceg</a></p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 听 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web知识</title>
      <link href="/2021/12/15/webqs/"/>
      <url>/2021/12/15/webqs/</url>
      
        <content type="html"><![CDATA[<h2 id="web-相关知识-web-相关知识"><a href="#web-相关知识-web-相关知识" class="headerlink" title="web 相关知识 web 相关知识"></a>web 相关知识 web 相关知识</h2><ol><li><p>Package.json 有什么用<br>定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境</p></li><li><p>对 webpack 的使用有哪些优化建议<br>• 缩小打包作用域<br>• 充分利用缓存，提升二次构建速度<br>• 使用高版本的 webpack</p><blockquote><p>来自 <a href="https://blog.csdn.net/qq_44722915/article/details/109101979">https://blog.csdn.net/qq_44722915/article/details/109101979</a></p></blockquote></li><li><p>重绘和回流有什么区别</p><ul><li>重绘<br>当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。</li><li>回流<br>当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的。</li><li>区别<br>回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流</li><li>比如：添加或者删除可见的 DOM 元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</li></ul></li><li><p>web 前端的优化策略</p><ol><li>减少不必要的消耗时间的 Http 请求数，是 web 前端开发技术的一个重要方面</li><li>优化文件的规模，这个过程包括压缩 JavaScript 和 CSS 文件以及对相应的代码进行优化。</li><li>减少 DNS 查找 DNS 查找的时间开销很大，这是国内许多网站的通病。</li><li>优化网页内容根据 CSS 这样的特性，要实现 web 的优化，可以考虑将样式表放在顶部。另外，可以将 script 放在底部，该举措是为了防止 script 脚本阻塞当前页面，从而造成下载速度较慢，页面的加载时间过长等问题的产生</li></ol></li><li><p>响应式布局是什么，如何实现响应式布局<br>响应式布局:是同一页面在不同的屏幕上有不同的布局，即只需要一套代码使页面适应不同的屏幕</p><ol><li>原生代码</li></ol><ul><li>百分比布局</li><li>媒体查询使用@media</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @media screen and (min-width: 768px)&#123; /*大于等于768*/</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>框架</li></ol><ul><li>elementui 的 24 栅格</li><li>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue知识</title>
      <link href="/2021/12/15/vueqs3/"/>
      <url>/2021/12/15/vueqs3/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-知识-2"><a href="#vue-知识-2" class="headerlink" title="vue 知识 2"></a>vue 知识 2</h2><ol><li><p>你是如何理解 Vue 的双向数据绑定的<br>VUE 是 MVVM 模式就是 Model–View–ViewModel 模式，对于双向绑定的理解，就是用户更新了 View，Model 的数据也自动被更新了，这种情况就是双向绑定。就是在单向绑定的基础上给可输入元素 input、textare 等添加了 change(input)事件,(change 事件触发，View 的状态就被更新了)来动态修改 model。<br>利用 Object.defineProperty 这个 API 实现了 Data 每个属性的监听和回调。</p><p>数据驱动页面方向：就是当去修改 Data 某一个属时，会通知观察者，然后观察者触发自身的回调数，进而重新渲染页面。</p></li><li><p>MVVM 和 MVC 有什么区别</p><p>MVC 是应用最广泛的软件架构之一<br>Model(模型),View(视图),Controller(控制器)。 这主要是基于分层的目的,让彼此的职责分开。C 即 Controller 指的是页面 逻辑。<br>MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。<br>MVC 中 Controller 演变成 MVVM 中的 ViewModel<br>-MVVM 通过数据来显示视图层而不是节点操作<br>-MVVM 主要解决了 MVC 中大量的 dom 操作使页面渲染性能降低，加载速度变慢，影响用户体验等问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>node搭建最简单的服务器</title>
      <link href="/2021/12/11/nodenotes/"/>
      <url>/2021/12/11/nodenotes/</url>
      
        <content type="html"><![CDATA[<h2 id="node-搭建最简单的服务器"><a href="#node-搭建最简单的服务器" class="headerlink" title="node 搭建最简单的服务器"></a>node 搭建最简单的服务器</h2><ol><li>引入 http 模块<br><code>var http = require(&quot;http&quot;)</code></li><li>创建监听，在有请求时，发送一个响应</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(function(request, response) &#123;</span><br><span class="line">response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;);    // 发送响应数据 &quot;Hello World&quot;</span><br><span class="line">response.end(&#x27;Hello World\n&#x27;);</span><br><span class="line">&#125;).listen(8888);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在服务器后台看打印一下<br><code>console.log(&#39;server runing in my server&#39;);</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何配置express</title>
      <link href="/2021/11/26/expressnote/"/>
      <url>/2021/11/26/expressnote/</url>
      
        <content type="html"><![CDATA[<h2 id="如何才能配置好-express"><a href="#如何才能配置好-express" class="headerlink" title="如何才能配置好 express"></a>如何才能配置好 express</h2><ol><li>安装 express 包<br><code>npm install express -g</code></li><li>创建 demo 项目<br><code>Express demo</code></li><li>进入 demo 项目<br><code>Cd demo</code></li><li>根据 pacakge.json 安装需要的东西<br><code>Npm i</code></li><li>安装脚手架(方便一点，可选)<br><code>npm install express -generator -g</code></li><li>启动脚手架<br><code>Npm start</code></li><li>输入 ip 地址和端口<br><a href="http://localhost:3000/">http://localhost:3000/</a></li><li>看到页面显示 Welcome to Express 几个大字就成功了</li></ol><p>​express 是一个开源的 node.js 项目框架，提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。<br><a href="https://www.expressjs.com.cn/">express 官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2021/11/14/gitqs2/"/>
      <url>/2021/11/14/gitqs2/</url>
      
        <content type="html"><![CDATA[<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><ol><li>从服务器克隆一个仓库<br><code>git clone ssh://example.com/~/www/project.git</code></li><li>从服务器拉取一个仓库<br><code>git pull &quot;仓库地址&quot;</code></li><li>查看状态<br><code>git status</code></li><li>查看不同内容<br><code>git diff</code></li><li>创建并切换分支<br><code>git checkout -b </code></li><li>跳转到主分支<br><code>git checkout master</code></li><li>添加变更过的文件<br><code>git add &quot;文件名&quot;</code></li><li>提交变更<br><code>git commit &quot;文件名&quot; -m &quot;版本信息&quot;</code></li><li>推送到自己的分支<br><code>git push origin &lt;branch&gt;</code></li><li>合并分支<br><code>git merge &quot;分支名&quot;</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git笔记</title>
      <link href="/2021/11/14/gitqs/"/>
      <url>/2021/11/14/gitqs/</url>
      
        <content type="html"><![CDATA[<h2 id="git-笔记"><a href="#git-笔记" class="headerlink" title="git 笔记"></a>git 笔记</h2><ol><li><p>什么是 git<br>git 是管理代码版本的工具，是分布式版本控制系统即订可以保存我们每一次的修改记录。而 github 是放代码口中央服务器，类似的还有 gitee</p></li><li><p>Git 与 SVN 区别<br>1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式(分布式即版本库在自己电脑上)的版本控制系统，例如 SVN，CVS 等，最核心的区别。<br>2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</p></li><li><p>如何创建 git 本地仓库并与远程仓库连接</p><ol><li>初始化本地仓库 <code>git init </code></li><li>设置邮箱和姓名要和远程仓库中的一致<br><code>git config --global user.email &quot;邮箱&quot;</code><br><code>git config --global user.name &quot;姓名&quot;</code></li><li>配置 SSH<code>ssh-keygen -t rsa -C &quot;邮箱名称&quot;</code></li><li>成功之后，打开 C:\Users\Administrator.ssh 目录下的 id_rsa.pub 文件复制文件内容</li><li>Gitee&#x2F;GitHub 官网登录 setting-&gt;SSH</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css新增特性</title>
      <link href="/2021/11/14/cssqs1/"/>
      <url>/2021/11/14/cssqs1/</url>
      
        <content type="html"><![CDATA[<ol><li><p>CSS3 新特性有哪些</p><ul><li>新增了一些选择器:nth-child(n)<br>:last-child</li><li>新增边框属性<br>boreder-radius:创圆角边框<br>border-sahdow:为素添加阴影</li><li>文字 word-wrap：normal 使用浏览器默认换行<br>break-all 允许在单词内换行<br>文字换行</li></ul></li><li><p>Css 选择器权重</p><ul><li>!important &gt;内联样式&gt;id 选择器&gt;class 类选择器&gt;元素选择器</li></ul></li><li><p>Css 兄弟选择器</p><table><thead><tr><th>选择器</th><th>详细</th></tr></thead><tbody><tr><td>+选择器</td><td>如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器 div+p</td></tr><tr><td>~ 选择器</td><td>作用是查找某一个指定元素的后面的所有兄弟结点。</td></tr><tr><td>Div p</td><td>选择 div 元素内所有的 p</td></tr><tr><td>div,p</td><td>选择所有 div 和 p 元素</td></tr></tbody></table></li><li><p>css 子选择器<br>p:first-child<br>指定只有当 p 元素是其父级的第一个子级的样式<br>p:Nth-child(2)<br>选择每个 p 元素是其父级元素的第二个子元素</p></li><li><p>伪类和伪元素</p></li></ol><ul><li>伪类<br>伪类 a:hover{}<br>○ hover 鼠标移上去的状态<br>○ Link 未访问链接的状态<br>○ Visited 已访问链接的标签状态<br>Activie 链接被瞬间激活时的状态<br>伪元素<br>类似于行内元素<br>伪元素::before</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是http</title>
      <link href="/2021/11/10/httpqs/"/>
      <url>/2021/11/10/httpqs/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-http"><a href="#什么是-http" class="headerlink" title="什么是 http"></a>什么是 http</h2><p>http 是 TCP&#x2F;IP 通信协议的最上层协议之一；https 相当于 http 添加； 数字证书加密功能。</p><h3 id="http-的特点"><a href="#http-的特点" class="headerlink" title="http 的特点"></a>http 的特点</h3><ul><li><p>HTTP 是无连接的:<br>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。案用这种方式可以节省传输时间。</p></li><li><p>HTTP 是媒体独立的:<br>只要客户端和服务器知道如何处理数据内容，任何类型数据都可以通过 HTTP 发送。可以发自己想发的任何信息。客户端以及服务器指定使用适合的 MIME-type 内容类型。</p></li><li><p>HTTP 是无状态的:<br>HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。则它必须重传，这样可能导致每次连接传送的数提信大。另一方面，在服务器不需要先前信息时它的应答就较快。</p></li></ul><h2 id="url-crack-dowm-with-me-哈哈"><a href="#url-crack-dowm-with-me-哈哈" class="headerlink" title="url crack dowm with me 哈哈"></a>url crack dowm with me 哈哈</h2><blockquote><p><a href="http://yes/?id=333&amp;vd=3101">http://yes:80?id=333&amp;vd=3101</a></p></blockquote><ol><li>？表示后面跟的是参数</li><li>&amp;用来分隔多个参数</li><li>&#x3D;后面是参数的值</li></ol><ul><li>HTTP 默认端口号是 80</li></ul><h2 id="Http-的请求方法"><a href="#Http-的请求方法" class="headerlink" title="Http 的请求方法"></a>Http 的请求方法</h2><p>HTTP&#x2F;1.1 协议中共定义了八种方法（有时也叫“动作”），来表明 Request-URL 指定的资源不同的操作方式<br>我们常用的两种请求方法： GET 和 POST 方法。</p><ul><li>GET 请求表示要获取内容，它不会修改服务器上的数据</li><li>POST 请求表示要提交内容，数据被包含在请求体中，通常会修改服务器上的内容。<br>POST 请求的参数放在请求体中网页上看不见，但可以通过 chrome 开发者工具或者抓包工具看见</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是tcp</title>
      <link href="/2021/11/10/tcpqs/"/>
      <url>/2021/11/10/tcpqs/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-tcp"><a href="#什么是-tcp" class="headerlink" title="什么是 tcp"></a>什么是 tcp</h2><p>Tcp&#x2F;ip 网络最常用的<strong>通信协议</strong>,是当今互联网的常用标准.它完成一次通信的 5 个步骤叫做 5 个层<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.piOczJGdSOBWEtAbvRdLZwAAAA?w=234&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="图片"></p><p>由图可以知道它是从数据下潜到物理，此协议的特征之一就是将数据分割成<strong>小包发送</strong>,分割后的各个数据叫做数据包.也因此这样的通信被叫做数据包通信。</p><ul><li>传输数据的流程<br><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.3BMpoRJ35AMKjH2K3qQ4LQFgCx?w=335&h=168&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="图片"></li></ul><p>发送数据是封包 打包的过程是不断加头的过程<br>接收方是做与发送方相反的过程即拆包</p>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css布局</title>
      <link href="/2021/10/27/cssqs2/"/>
      <url>/2021/10/27/cssqs2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-左侧固定右侧自适应？"><a href="#1-左侧固定右侧自适应？" class="headerlink" title="1.左侧固定右侧自适应？"></a>1.左侧固定右侧自适应？</h2><ul><li>flex-grow 都设置为 1<ul><li>flex-grow：这是 项目 的一个属性，定义了项目的放大 比例，如果为 0，即使有剩余空间也不会放大。 Flex-grow:1 设置它的放大比例为 1</li></ul></li><li><code>width: calc(100% - 300px);</code><br>算一下</li><li>float+margin-left，左侧宽度 ml 固定</li></ul><h2 id="2-aspect-ratio-CSS-新增长宽比"><a href="#2-aspect-ratio-CSS-新增长宽比" class="headerlink" title="2.aspect-ratio CSS 新增长宽比"></a>2.aspect-ratio CSS 新增长宽比</h2><p><code>aspect-ratio: width / height</code><br>&#x2F;&#x2F;aspect-ratio: 1 &#x2F; 2;</p><h2 id="未知宽高元素，如何实现居中？"><a href="#未知宽高元素，如何实现居中？" class="headerlink" title="未知宽高元素，如何实现居中？"></a>未知宽高元素，如何实现居中？</h2><ul><li>父元素 flex 盒子设置<br><code>justify-content:center; align-items:center;</code></li><li>父组件 <code>display: flex;</code>子组件设置<code>Margin: auto;</code></li></ul><h2 id="怎么垂直居中"><a href="#怎么垂直居中" class="headerlink" title="怎么垂直居中"></a>怎么垂直居中</h2><ul><li>1 Flex<br><code>Display:flex;align(使成为直线)-items:center</code></li><li>2 Table-cell<br>父元素</li></ul><figure class="highlight plaintext"><figcaption><span>table-cell;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text-align: center;</span><br><span class="line">vertical-align: middle;</span><br></pre></td></tr></table></figure><ul><li>3 Absolute 与 margin:auto<br>父元素<br><code>position: relative;</code><br>子元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">left: 0;</span><br><span class="line">top: 0;</span><br><span class="line">bottom:0;</span><br><span class="line">right:0;</span><br><span class="line">margin:auto;</span><br></pre></td></tr></table></figure><ul><li>4 Grid</li></ul><h2 id="屏幕三等分"><a href="#屏幕三等分" class="headerlink" title="屏幕三等分"></a>屏幕三等分</h2><ul><li><p>1 flex 布局<br>容器<br><code>display: flex;</code><br>组件<br><code>width: 33.3%;</code></p></li><li><p>2 float<br>子组件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width: 33.3%;</span><br><span class="line">float: left;</span><br></pre></td></tr></table></figure><ul><li>3 父元素 display:table + 子元素 display:table-cell</li></ul><h2 id="屏幕四等分"><a href="#屏幕四等分" class="headerlink" title="屏幕四等分"></a>屏幕四等分</h2><ul><li><p>1 flex 布局<br>容器<br><code>display: flex;</code><br>组件<br><code>width: 25%;</code></p></li><li><p>2 float<br>子组件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width: 25%;</span><br><span class="line">float: left;</span><br></pre></td></tr></table></figure><ul><li>3 父元素 display:table + 子元素 display:table-cell</li></ul><h2 id="如何垂直水平居中一个元素"><a href="#如何垂直水平居中一个元素" class="headerlink" title="如何垂直水平居中一个元素"></a>如何垂直水平居中一个元素</h2><ul><li><p>1 父相子绝,子元素设置<br>margin:auto<br>left&#x2F;right&#x2F;top&#x2F;bottom:0</p></li><li><p>2 父<code>Display:Table-cell;vertical-align:middle</code><br>子：<code>margin:0 auto;</code></p></li><li><p>3 父<code>display:flex;justify(两端对齐)-content:center;align-items:center</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>导入iconfont的方法</title>
      <link href="/2021/10/14/iconfontqs/"/>
      <url>/2021/10/14/iconfontqs/</url>
      
        <content type="html"><![CDATA[<h2 id="导入-iconfont-的方法"><a href="#导入-iconfont-的方法" class="headerlink" title="导入 iconfont 的方法"></a>导入 iconfont 的方法</h2><ol><li>在 main.js 文件里面导入 iconfont.css 文件</li><li>可以在 css 文件里导入<br><code>@import url(&#39;https://xxx&#39;)</code></li></ol><ul><li>使用的时候<br><code>&lt;i class=&quot;iconfont icon-add&quot;&gt;&lt;/i&gt;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在vue项目中用axios请求数据的方法</title>
      <link href="/2021/10/10/axiosguide/"/>
      <url>/2021/10/10/axiosguide/</url>
      
        <content type="html"><![CDATA[<h2 id="在-vue-项目中用-axios-请求数据的方法"><a href="#在-vue-项目中用-axios-请求数据的方法" class="headerlink" title="在 vue 项目中用 axios 请求数据的方法"></a>在 vue 项目中用 axios 请求数据的方法</h2><ol><li>创建 vue 项目<br><code>vue create myaxios</code></li><li>安装 axios 包<br><code>npm i axios</code></li><li>在 vue 项目的 main.js 中导入<br><code>import Axios from &#39;axios&#39;</code></li><li>挂载到 vue 上<br><code>Vue.prototype.$axios = Axios</code></li><li>此时就可以用 this.$axios 来使用了</li><li>直接发起请求,here im using get way</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.$axios(&#123;</span><br><span class="line">method: &quot;GET&quot;,</span><br><span class="line">url: &quot;http://localhost:3000/search/hot/detail&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">.then((resp) =&gt; &#123;</span><br><span class="line">console.log(&quot;111 后端有返回&quot;);</span><br><span class="line">console.log(resp);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="7"><li>如果控制台打印出数据，我们第一次在 vue 的 axios 请求就成功了 嘻嘻</li></ol>]]></content>
      
      
      <categories>
          
          <category> 手册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap是什么</title>
      <link href="/2021/09/15/bootstrapqs/"/>
      <url>/2021/09/15/bootstrapqs/</url>
      
        <content type="html"><![CDATA[<pre><code>是web开发库,最具特色的是它的css样式，模态框，13分栏布局而jquery是一个 JavaScript 库</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>express安装过程中出错</title>
      <link href="/2021/09/10/expressinstallfix/"/>
      <url>/2021/09/10/expressinstallfix/</url>
      
        <content type="html"><![CDATA[<h2 id="express-安装过程出错"><a href="#express-安装过程出错" class="headerlink" title="express 安装过程出错"></a>express 安装过程出错</h2><table><thead><tr><th>问题</th><th>找到的原因</th></tr></thead><tbody><tr><td>If you believe this might be a permissions issue,please double-check the</td><td>这个要用管理员权限打开 vscode</td></tr><tr><td>npm start npm ERR! Missing script: “start”</td><td>这个是我们刚刚创建了一个 express 文件 但是我们没有进入该文件 cd demo</td></tr><tr><td>Error: Cannot find module ‘cookie-parser’Require stack:</td><td>重新创建一个就没有问题了</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编程英语</title>
      <link href="/2021/09/02/codewords/"/>
      <url>/2021/09/02/codewords/</url>
      
        <content type="html"><![CDATA[<h2 id="编程单词"><a href="#编程单词" class="headerlink" title="编程单词"></a>编程单词</h2><table><thead><tr><th>单词</th></tr></thead><tbody><tr><td>Token 令牌，标记</td></tr><tr><td>property 属性，{对象}里面的东西</td></tr><tr><td>Assign to ：给赋值，布置</td></tr><tr><td>mount 网络挂载；安装；挂接</td></tr><tr><td>proxy 网络代理伺服器；代理服务器；代理模式</td></tr><tr><td>ui user interface 的意思</td></tr><tr><td>modify 修改的；修正</td></tr><tr><td>import 导入数据</td></tr><tr><td>export 输出其它格式文件</td></tr><tr><td>component 组件；元件；构件</td></tr><tr><td>ui user interface 的意思</td></tr><tr><td>router 无线路由器</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VUE知识2</title>
      <link href="/2021/08/08/vueqs/"/>
      <url>/2021/08/08/vueqs/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是-MVVM-模式"><a href="#1-什么是-MVVM-模式" class="headerlink" title="1.什么是 MVVM 模式"></a>1.什么是 MVVM 模式</h2><p>MVVM 是 Model、view、view-model 的缩写。</p><ul><li>Model 代表数据层，用于存储数据和对数据进行增删改查</li><li>view 代表视图层，即 UI 界面，用于将数据模型转化成 UI 展现出来</li><li>view-model 通过双向数据连接前两者。当 Model 数据改变时通过它改 View 变视图层;反之 View 视图层改变时通过它改变 Model 数据层</li></ul><h2 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2.双向数据绑定的原理"></a>2.双向数据绑定的原理</h2><p>Vue 数据双向绑定原理是通过<strong>数据劫持</strong>结合<strong>发布者-订阅者</strong>模式的方式来实现的。首先对数据进行<strong>监听</strong>，然后当监听的属性发生变化时则告诉<strong>订阅者</strong>是否要更新，若更新就会执行对应的<strong>更新函数</strong>从而更新视图</p><h2 id="3-数据劫持的原理"><a href="#3-数据劫持的原理" class="headerlink" title="3.数据劫持的原理"></a>3.数据劫持的原理</h2><p>通过“Object.defineProperty()”方法来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调,来更新函数</p><h2 id="4-vue-和-react-的区别？"><a href="#4-vue-和-react-的区别？" class="headerlink" title="4.vue 和 react 的区别？"></a>4.vue 和 react 的区别？</h2><ol><li><p><strong>组件写法差异</strong></p><ul><li>React 推荐的做法是 JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中,即 all in js</li><li>Vue 推荐的做法是 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解),即 html,css,JS 写在同一个文件(vue 也支持 JSX 写法)</li></ul></li><li><p><strong>diff 算法不同</strong></p><ul><li>Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。</li><li>React 的 Diff 算法，是传统 Diff 算法循环递归每一个节点。同样情况下可以 Vue 的 diff 算法减少移动节点次数，减少不必要的性能损耗</li></ul></li><li><p><strong>响应式原理不同</strong></p><ul><li>Vue 自动优化，数据可变。当数据改变时，自动找到引用组件重新渲染</li><li>React 基于状态机，手动优化，数据不可变，需要 setState 驱动新的 state 替换老的 state</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>彭雨晴的第一篇文章</title>
      <link href="/2020/11/09/emogirl/"/>
      <url>/2020/11/09/emogirl/</url>
      
        <content type="html"><![CDATA[<h1 id="这是我的第一文章"><a href="#这是我的第一文章" class="headerlink" title="这是我的第一文章"></a>这是我的第一文章</h1><p>歌曲<a href="https://www.bilibili.com/video/BV17u41197bS/?share_source=copy_web&vd_source=813b0cfea1023c3f2aca017db97a712c">emo girl</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
